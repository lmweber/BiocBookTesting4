[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Best Practices for Spatial Transcriptomics Analysis with Bioconductor",
    "section": "",
    "text": "Welcome\nThis is the website for the online book ‘Best Practices for Spatial Transcriptomics Analysis with Bioconductor’.\nThis book provides discussion and interactive examples on best practices for computational analysis workflows for spatial transcriptomics data, using the Bioconductor framework within R. The chapters contain details on individual analysis steps as well as complete example workflows, with interactive example datasets and R code.\nThe book is organized into several parts, including introductory materials, analysis steps, and example workflows.\nAdditional details on analysis workflows for non-spatial single-cell data as well as further introductory materials on R and Bioconductor can be found in the related book Orchestrating Single-Cell Analysis with Bioconductor (OSCA)."
  },
  {
    "objectID": "chapters/introduction.html#overview",
    "href": "chapters/introduction.html#overview",
    "title": "1  Introduction",
    "section": "1.1 Overview",
    "text": "1.1 Overview\nThis book provides discussion and interactive examples on best practices for computational analysis workflows for spatial transcriptomics data, using the Bioconductor framework within R."
  },
  {
    "objectID": "chapters/introduction.html#contents",
    "href": "chapters/introduction.html#contents",
    "title": "1  Introduction",
    "section": "1.2 Contents",
    "text": "1.2 Contents\nThe chapters are organized into several parts:\n\nIntroduction: introduction, background on spatial transcriptomics, and R/Bioconductor data classes\nAnalysis steps: individual analysis steps\nWorkflows: examples of complete analysis workflows\nAppendix: related resources, acknowledgments, and references"
  },
  {
    "objectID": "chapters/introduction.html#scope-and-who-this-book-is-for",
    "href": "chapters/introduction.html#scope-and-who-this-book-is-for",
    "title": "1  Introduction",
    "section": "1.3 Scope and who this book is for",
    "text": "1.3 Scope and who this book is for\nThe aim of this book is to demonstrate best practices for computational analysis workflows for spatial transcriptomics data through interactive examples and discussion using R code and example datasets. We assume some familiarity with R programming and an understanding of the types of biological questions that single-cell and spatial transcriptomics can be used to answer. Previous experience with Bioconductor is not required. By working through the examples in this book, readers will be able to adapt or extend the example workflows to analyze their own data.\nIn general, we focus on downstream analysis methods, which start with a gene expression count table and spatial coordinates as the main inputs. Preprocessing procedures to generate gene expression count tables are covered in other resources (e.g. our related book Visium Data Preprocessing for data from the 10x Genomics Visium platform) and tutorials provided by the manufacturers of the technological platforms. For molecule-based platforms, we will usually use data that has been aggregated to the cell level.\nFor analysis steps where a number of different methods are available, we will showcase examples of methods that we have found to work well and are computationally scalable, with a preference for methods available through Bioconductor.\nAll methods used in this book are available through Bioconductor or CRAN (in R) or PyPI (in Python) to ensure installability and long-term maintenance. We also mention a number of additional methods that are available as packages from GitHub, but these are not run within the code examples."
  },
  {
    "objectID": "chapters/introduction.html#bioconductor",
    "href": "chapters/introduction.html#bioconductor",
    "title": "1  Introduction",
    "section": "1.4 Bioconductor",
    "text": "1.4 Bioconductor\nBioconductor is an ‘open source and open development’ project providing a cohesive and flexible framework for rigorous and reproducible analyses of high-throughput genomic data in R (Huber et al. 2015). Bioconductor provides access to more than 2,000 contributed R packages, as well as infrastructure maintained by the Bioconductor Core Team, providing a rich analysis environment for users.\nA key strength of the Bioconductor framework is the modularity and open development philosophy. R packages are contributed by numerous research groups around the world, with the Bioconductor Core Team coordinating the overall project and maintaining infrastructure, build testing, and development guidelines. Contributed packages use consistent data structures, enabling users to connect packages developed by different groups to build analysis workflows that include the latest state-of-the-art methods. Bioconductor packages also include comprehensive documentation, including long-form tutorials or package vignettes."
  },
  {
    "objectID": "chapters/introduction.html#additional-resources",
    "href": "chapters/introduction.html#additional-resources",
    "title": "1  Introduction",
    "section": "1.5 Additional resources",
    "text": "1.5 Additional resources\nFor readers who are new to R and Bioconductor, additional useful resources include:\n\nThe Orchestrating Single-Cell Analysis with Bioconductor (OSCA) online book (Amezquita et al. 2020), which contains comprehensive materials on analysis workflows for non-spatial single-cell data as well as further introductory materials on R and Bioconductor.\nThe R for Data Science online book provides an excellent introduction to R.\nData Carpentry and Software Carpentry provide online lesson materials on R programming, the Unix shell, and version control.\nThe R/Bioconductor Data Science Team at the Lieber Institute for Brain Development has a detailed guide of free resources and videos to learn more about R and Bioconductor, as well as YouTube videos, including some on the basics of Bioconductor and infrastructure for storing gene expression data.\nThe Visium Data Preprocessing online book provides details on data preprocessing procedures for spatial transcriptomics data from the 10x Genomics Visium platform."
  },
  {
    "objectID": "chapters/introduction.html#contributions",
    "href": "chapters/introduction.html#contributions",
    "title": "1  Introduction",
    "section": "1.6 Contributions",
    "text": "1.6 Contributions\nWe welcome suggestions for updates and additions to the book. Suggestions may be provided as GitHub issues for further discussion with the maintainers.\nNote that all methods to be run within code examples must be available as either R packages from Bioconductor or CRAN, or Python packages from PyPI. This restriction provides readers with guarantees regarding installability, long-term availability, maintenance, and compatibility. Packages that are only available from GitHub or other repositories may be discussed within the text, but will not be included in the code examples. In general, our philosophy is to showcase examples of analysis methods that we have found to work well, are computationally scalable, user-friendly, and which can be integrated into existing Bioconductor-based workflows.\n\n\n\n\nAmezquita, Robert A., Aaron T. L. Lun, Etienne Becht, Vince J. Carey, Lindsay N. Carpp, Ludwig Geistlinger, Federico Marini, et al. 2020. “Orchestrating Single-Cell Analysis with Bioconductor.” Nature Methods 17: 137–45. https://doi.org/10.1038/s41592-019-0654-x.\n\n\nHuber, Wolfgang, Vincent J. Carey, Robert Gentleman, Simon Anders, Marc Carlson, Benilton S. Carvalho, Hector Corrada Bravo, et al. 2015. “Orchestrating High-Throughput Genomic Analysis with Bioconductor.” Nature Methods 12: 115–21. https://doi.org/10.1038/nmeth.3252."
  },
  {
    "objectID": "chapters/spatial-transcriptomics.html#overview",
    "href": "chapters/spatial-transcriptomics.html#overview",
    "title": "2  Spatial transcriptomics",
    "section": "2.1 Overview",
    "text": "2.1 Overview\nSpatial transcriptomics (or spatially-resolved transcriptomics) refers to high-throughput genomic technological platforms that enable the measurement of high-dimensional gene expression at spatial resolution. Depending on the platform, this can include up to transcriptome-scale gene expression at up to thousands of measurement locations per tissue sample, usually on two-dimensional tissue sections. Spatially-resolved transcriptomics was named the Method of the Year 2020 by Nature Methods, and has found widespread application in numerous biological systems.\nA number of technological platforms have been developed, using a wide variety of technologies and experimental procedures. Platforms vary widely in terms of gene coverage, spatial resolution, and sensitivity and specificity. For users deciding between platforms, the tradeoff between gene coverage and spatial resolution is often a key consideration.\nPlatforms may be grouped into ‘sequencing-based’ and ‘molecule-based’ (or ‘imaging-based’) platforms, which are described in more detail below. In general, sequencing-based platforms provide higher gene coverage (up to transcriptome-scale, i.e. thousands of genes), while molecule-based platforms provide higher spatial resolution (single-cell or sub-cellular resolution).\nIn this book, we focus on data from commercially available platforms, since these are the most accessible and widely used platforms. In this chapter, we provide a short overview and links to additional information on several key platforms.\nFor more in-depth background, several recent reviews are available, e.g. Bressan, Battistoni, and Hannon (2023) and Moses and Pachter (2022), which discuss available technological platforms, computational analysis methods, outstanding challenges, and additional topics."
  },
  {
    "objectID": "chapters/spatial-transcriptomics.html#sequencing-based-platforms",
    "href": "chapters/spatial-transcriptomics.html#sequencing-based-platforms",
    "title": "2  Spatial transcriptomics",
    "section": "2.2 Sequencing-based platforms",
    "text": "2.2 Sequencing-based platforms\nSequencing-based platforms capture messenger RNA (mRNA) molecules at a set of spatial measurement locations on a tissue section placed on a slide, tag the mRNAs with unique spatial barcodes for each measurement location, and generate a readout by sequencing.\nThese platforms can provide full-transcriptome gene coverage (i.e. &gt;10,000 genes) due to the use of sequencing, which does not require pre-selection of genes of interest. The spatial resolution varies between platforms, and depends on the size and spacing between the spatial capture locations. However, depending on the spatial resolution and tissue cell density, each spatial location may contain measurements from one or more cells, and capture locations may or may not overlap with individual cells, so these platforms generally do not provide single-cell spatial resolution.\nSpatial measurement locations for sequencing-based platforms are often referred to as ‘spots’ or ‘beads’. In this book, we will usually use the terminology ‘spots’.\n\n2.2.1 10x Genomics Visium\nThe 10x Genomics Visium platform measures transcriptome-scale gene expression at a grid of spatial locations (referred to as spots) on a tissue capture area on a slide. Either fresh-frozen or formalin-fixed paraffin-embedded (FFPE) tissue may be used. Each spot contains millions of spatially-barcoded capture oligonucleotides, which bind to mRNAs from the tissue. A cDNA library is then generated for sequencing, which includes the spatial barcodes, allowing reads to be mapped back to their spatial locations.\nThe array dimensions are 6.5 x 6.5 mm, with around 5,000 barcoded spots. Spots are 55 µm in diameter and spaced 100 µm center-to-center in a hexagonal grid arrangement. The number of cells overlapping with each spot depends on the tissue cell density, e.g. around 0-10 for human brain tissue or ~50 for mouse brain tissue. Each Visium slide contains four tissue capture areas. The following figure provides an illustration.\nHistology images generated from hematoxylin and eosin (H&E) staining can be used to identify anatomical and cell morphological features for each sample, including the number of cells per spot.\nThe 10x Genomics Visium platform is based on the original technological implementation developed by Ståhl et al. (2016).\n\n\n\n\n\nSchematic illustrating the 10x Genomics Visium platform. Source: 10x Genomics Visium\n\n\n\n\n\n\n2.2.2 10x Genomics Visium HD\nThe 10x Genomics Visium HD platform provides higher spatial resolution. Capture area dimensions are 6.5 x 6.5 mm, with a continuous ‘lawn’ of capture oligonucleotides arranged into 2 x 2 µm barcoded squares, which can optionally be aggregated into larger 8 x 8 µm bins. There are no gaps between the squares, and there are two capture areas per slide. The high spatial resolution of the barcoded squares provide near-single-cell resolution, while the use of sequencing provides transcriptome-scale gene coverage.\n\n\n2.2.3 Curio Seeker\nThe Curio Seeker platform is a commercially available implementation and extension of the original Slide-seqV2 (Stickels et al. 2021) platform.\nThe Curio Seeker platform captures mRNA molecules at a set of randomly placed measurement locations (referred to as ‘beads’) on a tissue slide (referred to as a ‘tile’) at high spatial resolution. The tile dimensions are 3 mm x 3 mm, and the spatial resolution consists of tightly packed 10 µm diameter beads."
  },
  {
    "objectID": "chapters/spatial-transcriptomics.html#molecule-based-platforms",
    "href": "chapters/spatial-transcriptomics.html#molecule-based-platforms",
    "title": "2  Spatial transcriptomics",
    "section": "2.3 Molecule-based platforms",
    "text": "2.3 Molecule-based platforms\nMolecule-based (or imaging-based) platforms identify the spatial locations of individual RNA molecules by sequential in situ hybridization (ISH) or by in situ sequencing (ISS), for targeted sets of up to hundreds or thousands of genes at single-cell or sub-cellular spatial resolution.\nImage segmentation is used to identify the boundaries of individual cells and assign RNA molecules to cells or nuclei during preprocessing. For downstream analyses, gene counts may be aggregated to the cell level, or analyses may be performed directly at the molecule level. Cell-level analyses can re-use methods developed for spot-level spatial transcriptomics data or single-cell data, while molecule-level analyses may require new methods.\nThe selection of targeted sets of biologically informative genes for an experiment, referred to as panel design, is a key consideration during experimental design. Several commercially available options for targeted gene sets suitable for certain biological systems are available.\n\n2.3.1 10x Genomics Xenium\nDetails on the 10x Genomics Xenium platform are available from 10x Genomics.\n\n\n2.3.2 Vizgen MERSCOPE\nDetails on the Vizgen MERSCOPE platform are available from Vizgen.\n\n\n2.3.3 NanoString CosMx\nDetails on the NanoString CosMx platform are available from NanoString.\n\n\n\n\nBressan, Dario, Giorgia Battistoni, and Gregory J. Hannon. 2023. “The Dawn of Spatial Omics.” Science 381 (6657). https://doi.org/10.1126/science.abq4964.\n\n\nMoses, Lambda, and Lior Pachter. 2022. “Museum of Spatial Transcriptomics.” Nature Methods 19: 534–46. https://doi.org/10.1038/s41592-022-01409-2.\n\n\nStåhl, Patrik L., Fredrik Salmén, Sanja Vickovic, Anna Lundmark, José Fernández Navarro, Jens Magnusson, Stefania Giacomello, et al. 2016. “Visualization and Analysis of Gene Expression in Tissue Sections by Spatial Transcriptomics.” Science 353 (6294): 78–82. https://doi.org/10.1126/science.aaf2403.\n\n\nStickels, Robert R., Evan Murray, Pawan Kumar, Jilong Li, Jamie L. Marshall, Daniela J. Di Bella, Paola Arlotta, Evan Z. Macosko, and Fei Chen. 2021. “Highly Sensitive Spatial Transcriptomics at Near-Cellular Resolution with Slide-seqV2.” Nature Biotechnology 39: 313–19. https://doi.org/10.1038/s41587-020-0739-1."
  },
  {
    "objectID": "chapters/bioconductor-data-classes.html#overview",
    "href": "chapters/bioconductor-data-classes.html#overview",
    "title": "3  Bioconductor data classes",
    "section": "3.1 Overview",
    "text": "3.1 Overview\nBioconductor provides several data classes for storing and manipulating spatial transcriptomics datasets. By relying on these standardized data structures, we can build analysis workflows that can easily connect methods and packages developed by different research groups.\nBelow, we describe the Bioconductor data classes used in this book."
  },
  {
    "objectID": "chapters/bioconductor-data-classes.html#spatialexperiment-class",
    "href": "chapters/bioconductor-data-classes.html#spatialexperiment-class",
    "title": "3  Bioconductor data classes",
    "section": "3.2 SpatialExperiment class",
    "text": "3.2 SpatialExperiment class\nThe SpatialExperiment class (Righelli et al. 2022) is the core data class that we use in this book. This class allows us to store datasets at the spot or cell level, i.e. data from sequencing-based platforms (e.g. 10x Genomics Visium) at the spot level, or data from molecule-based platforms that has been aggregated to the cell level.\nSpatialExperiment builds on the SingleCellExperiment class (Amezquita et al. 2020) for single-cell RNA sequencing data, with additional customizations to store spatial information, such as spatial coordinates and image files.\nA summary of the SpatialExperiment object structure is shown in the following schematic. Briefly, a SpatialExperiment object consists of (i) assays containing expression counts, (ii) rowData containing information on features, i.e. genes, (iii) colData containing information on spots or cells, including nonspatial and spatial metadata, (iv) spatialCoords containing spatial coordinates, and (v) imgData containing image data. For spot-based data (e.g. 10x Genomics Visium), a single assay named counts is used.\nFor more details, see the SpatialExperiment package Bioconductor vignette or the paper describing the class (Righelli et al. 2022).\n\n\n\n\n\nOverview of the SpatialExperiment data class for storing and manipulating spatial transcriptomics datasets within the Bioconductor framework."
  },
  {
    "objectID": "chapters/bioconductor-data-classes.html#molecule-based-data",
    "href": "chapters/bioconductor-data-classes.html#molecule-based-data",
    "title": "3  Bioconductor data classes",
    "section": "3.3 Molecule-based data",
    "text": "3.3 Molecule-based data\nMolecule-based spatial transcriptomics datasets contain additional information, including the spatial coordinates of individual mRNA molecules and segmentation boundaries for cells or nuclei.\nThe following Bioconductor classes provide additional functionality to store and manipulate this information.\nThese classes extend SpatialExperiment and are compatible with SpatialExperiment for analyses at the aggregated cell level.\n\n3.3.1 MoleculeExperiment\nMoleculeExperiment is available as a Bioconductor package and described by the authors in their paper (Peters Couto et al. 2023).\n\n\n3.3.2 SpatialFeatureExperiment\nSpatialFeatureExperiment is available as a Bioconductor package and described by the authors in their paper (Moses et al. 2023).\n\n\n\n\n\nAmezquita, Robert A., Aaron T. L. Lun, Etienne Becht, Vince J. Carey, Lindsay N. Carpp, Ludwig Geistlinger, Federico Marini, et al. 2020. “Orchestrating Single-Cell Analysis with Bioconductor.” Nature Methods 17: 137–45. https://doi.org/10.1038/s41592-019-0654-x.\n\n\nMoses, Lambda, Pétur Helgi Einarsson, Kayla Jackson, Laura Luebbert, A. Sina Booeshaghi, Sindri Antonsson, Nicolas Bray, Páll Melsted, and Lior Pachter. 2023. “Voyager: Exploratory Single-Cell Genomics Data Analysis with Geospatial Statistics.” bioRxiv. https://doi.org/10.1101/2023.07.20.549945.\n\n\nPeters Couto, Bárbara Zita, Nicholas Robertson, Ellis Patrick, and Shila Ghazanfar. 2023. “MoleculeExperiment Enables Consistent Infrastructure for Molecule-Resolved Spatial Transcriptomics Data in Bioconductor.” bioRxiv. https://doi.org/10.1101/2023.05.16.541040.\n\n\nRighelli, Dario, Lukas M. Weber, Helena L. Crowell, Brenda Pardo, Leonardo Collado-Torres, Shila Ghazanfar, Aaron T. L. Lun, Stephanie C. Hicks, and Davide Risso. 2022. “SpatialExperiment: Infrastructure for Spatially-Resolved Transcriptomics Data in R Using Bioconductor.” Bioinformatics 38 (11): 3128–31. https://doi.org/10.1093/bioinformatics/btac299."
  },
  {
    "objectID": "chapters/analysis-steps.html",
    "href": "chapters/analysis-steps.html",
    "title": "4  Analysis steps",
    "section": "",
    "text": "This part contains chapters describing individual analysis steps within computational analysis workflows for spatial transcriptomics data.\nEach chapter describes the analysis type, including discussion on statistical issues and available methods, and provides an interactive example with R code and an example dataset.\nIn the next chapter, we load a dataset in SpatialExperiment format (see Chapter 3), which will be used in several of the subsequent chapters.\nFor examples of complete analysis workflows for selected datasets and technological platforms, see the next part (Chapter 16)."
  },
  {
    "objectID": "chapters/load-data.html#overview",
    "href": "chapters/load-data.html#overview",
    "title": "5  Load data",
    "section": "5.1 Overview",
    "text": "5.1 Overview\nIn the following chapters, we apply analysis methods to spatial transcriptomics datasets that are formatted as SpatialExperiment objects or objects from other Bioconductor data classes (see Chapter 3).\nHere, we load a 10x Genomics Visium dataset that will be used in several of the following chapters.\nThis dataset has previously been preprocessed using data preprocessing procedures with tools outside R and saved in SpatialExperiment format. For more details on data preprocessing procedures for the 10x Genomics Visium platform, see the related online book Visium Data Preprocessing.\nThis dataset is available for download in SpatialExperiment format from the STexampleData Bioconductor package."
  },
  {
    "objectID": "chapters/load-data.html#dataset",
    "href": "chapters/load-data.html#dataset",
    "title": "5  Load data",
    "section": "5.2 Dataset",
    "text": "5.2 Dataset\nThis dataset consists of one sample (Visium capture area) from one donor, consisting of postmortem human brain tissue from the dorsolateral prefrontal cortex (DLPFC) brain region, measured with the 10x Genomics Visium platform. The dataset is described in the original publication by Maynard et al. (2021).\nMore details on the dataset are also included in Chapter 17."
  },
  {
    "objectID": "chapters/load-data.html#load-data",
    "href": "chapters/load-data.html#load-data",
    "title": "5  Load data",
    "section": "5.3 Load data",
    "text": "5.3 Load data\nDownload and load the dataset in SpatialExperiment format from the STexampleData Bioconductor package.\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\n\n# load object\nspe &lt;- Visium_humanDLPFC()"
  },
  {
    "objectID": "chapters/load-data.html#spatialexperiment-object",
    "href": "chapters/load-data.html#spatialexperiment-object",
    "title": "5  Load data",
    "section": "5.4 SpatialExperiment object",
    "text": "5.4 SpatialExperiment object\nCheck the structure of the SpatialExperiment object. For more details on the SpatialExperiment structure, see Chapter 3.\n\n# check object\nspe\n\nclass: SpatialExperiment \ndim: 33538 4992 \nmetadata(0):\nassays(1): counts\nrownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475\n  ENSG00000268674\nrowData names(3): gene_id gene_name feature_type\ncolnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ...\n  TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1\ncolData names(7): barcode_id sample_id ... ground_truth cell_count\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(4): sample_id image_id data scaleFactor\n\n# number of genes (rows) and spots (columns)\ndim(spe)\n\n[1] 33538  4992\n\n# names of 'assays'\nassayNames(spe)\n\n[1] \"counts\"\n\n# row (gene) data\nhead(rowData(spe))\n\nDataFrame with 6 rows and 3 columns\n                        gene_id   gene_name    feature_type\n                    &lt;character&gt; &lt;character&gt;     &lt;character&gt;\nENSG00000243485 ENSG00000243485 MIR1302-2HG Gene Expression\nENSG00000237613 ENSG00000237613     FAM138A Gene Expression\nENSG00000186092 ENSG00000186092       OR4F5 Gene Expression\nENSG00000238009 ENSG00000238009  AL627309.1 Gene Expression\nENSG00000239945 ENSG00000239945  AL627309.3 Gene Expression\nENSG00000239906 ENSG00000239906  AL627309.2 Gene Expression\n\n# column (spot) data\nhead(colData(spe))\n\nDataFrame with 6 rows and 7 columns\n                           barcode_id     sample_id in_tissue array_row\n                          &lt;character&gt;   &lt;character&gt; &lt;integer&gt; &lt;integer&gt;\nAAACAACGAATAGTTC-1 AAACAACGAATAGTTC-1 sample_151673         0         0\nAAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 sample_151673         1        50\nAAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 sample_151673         1         3\nAAACACCAATAACTGC-1 AAACACCAATAACTGC-1 sample_151673         1        59\nAAACAGAGCGACTCCT-1 AAACAGAGCGACTCCT-1 sample_151673         1        14\nAAACAGCTTTCAGAAG-1 AAACAGCTTTCAGAAG-1 sample_151673         1        43\n                   array_col ground_truth cell_count\n                   &lt;integer&gt;  &lt;character&gt;  &lt;integer&gt;\nAAACAACGAATAGTTC-1        16           NA         NA\nAAACAAGTATCTCCCA-1       102       Layer3          6\nAAACAATCTACTAGCA-1        43       Layer1         16\nAAACACCAATAACTGC-1        19           WM          5\nAAACAGAGCGACTCCT-1        94       Layer3          2\nAAACAGCTTTCAGAAG-1         9       Layer5          4\n\n# spatial coordinates\nhead(spatialCoords(spe))\n\n                   pxl_col_in_fullres pxl_row_in_fullres\nAAACAACGAATAGTTC-1               3913               2435\nAAACAAGTATCTCCCA-1               9791               8468\nAAACAATCTACTAGCA-1               5769               2807\nAAACACCAATAACTGC-1               4068               9505\nAAACAGAGCGACTCCT-1               9271               4151\nAAACAGCTTTCAGAAG-1               3393               7583\n\n# image data\nimgData(spe)\n\nDataFrame with 2 rows and 4 columns\n      sample_id    image_id   data scaleFactor\n    &lt;character&gt; &lt;character&gt; &lt;list&gt;   &lt;numeric&gt;\n1 sample_151673      lowres   ####   0.0450045\n2 sample_151673       hires   ####   0.1500150"
  },
  {
    "objectID": "chapters/load-data.html#build-object",
    "href": "chapters/load-data.html#build-object",
    "title": "5  Load data",
    "section": "5.5 Build object",
    "text": "5.5 Build object\nAlternatively, we can also build a SpatialExperiment object directly from raw data.\nHere, we provide a short example with an empty dataset.\nFor more details, including how to load raw data from the 10x Genomics Space Ranger output files to build an object, or how to add image data to the object, see the SpatialExperiment documentation.\n\n# create data\nn_genes &lt;- 200\nn_spots &lt;- 100\n\ncounts &lt;- matrix(0, nrow = n_genes, ncol = n_spots)\n\nrow_data &lt;- DataFrame(\n  gene_name = paste0(\"gene\", sprintf(\"%03d\", seq_len(n_genes)))\n)\n\ncol_data &lt;- DataFrame(\n  sample_id = rep(\"sample01\", n_spots)\n)\n\nspatial_coords &lt;- matrix(0, nrow = n_spots, ncol = 2)\ncolnames(spatial_coords) &lt;- c(\"x\", \"y\")\n\n# create SpatialExperiment object\nspe &lt;- SpatialExperiment(\n  assays = list(counts = counts), \n  colData = col_data, \n  rowData = row_data, \n  spatialCoords = spatial_coords\n)"
  },
  {
    "objectID": "chapters/load-data.html#molecule-based-data",
    "href": "chapters/load-data.html#molecule-based-data",
    "title": "5  Load data",
    "section": "5.6 Molecule-based data",
    "text": "5.6 Molecule-based data\nFor more details on data classes for molecule-based platforms, e.g. 10x Genomics Xenium or Vizgen MERSCOPE, see Chapter 3.\n\n\n\n\nMaynard, Kristen R., Leonardo Collado-Torres, Lukas M. Weber, Cedric Uytingco, Brianna K. Barry, Stephen R. Williams, Joseph L. Catallini II, et al. 2021. “Transcriptome-Scale Spatial Gene Expression in the Human Dorsolateral Prefrontal Cortex.” Nature Neuroscience 24: 425–36. https://doi.org/10.1038/s41593-020-00787-0."
  },
  {
    "objectID": "chapters/quality-control.html#overview",
    "href": "chapters/quality-control.html#overview",
    "title": "6  Quality control",
    "section": "6.1 Overview",
    "text": "6.1 Overview\nQuality control (QC) procedures at the spot level aim to remove low-quality spots before further analysis. Low-quality spots can occur due to problems during library preparation or other experimental procedures. Examples include large proportions of dead cells due to cell damage during library preparation, and low mRNA capture efficiency due to inefficient reverse transcription or PCR amplification.\nThese spots are usually removed prior to further analysis, since otherwise they tend to create problems during downstream analyses such as clustering. For example, problematic spots that are not removed could show up as separate clusters, which may be misidentified as distinct cell types.\nLow-quality spots can be identified according to several characteristics, including:\n\nlibrary size (i.e. total UMI counts per spot)\nnumber of expressed features (i.e. number of genes with non-zero UMI counts per spot)\nproportion of reads mapping to mitochondrial genes (a high proportion indicates cell damage)\nnumber of cells per spot (unusually high values can indicate problems)\n\nLow library size or low number of expressed features can indicate poor mRNA capture rates, e.g. due to cell damage and missing mRNAs, or low reaction efficiency. A high proportion of mitochondrial reads indicates cell damage, e.g. partial cell lysis leading to leakage and missing cytoplasmic mRNAs, with the resulting reads therefore concentrated on the remaining mitochondrial mRNAs that are relatively protected inside the mitochondrial membrane. Unusually high numbers of cells per spot can indicate problems during cell segmentation.\nThe first three characteristics listed above are also used for QC in scRNA-seq data. However, the expected distributions for high-quality spots are different (compared to high-quality cells in scRNA-seq), since spots may contain zero, one, or multiple cells."
  },
  {
    "objectID": "chapters/quality-control.html#load-data",
    "href": "chapters/quality-control.html#load-data",
    "title": "6  Quality control",
    "section": "6.2 Load data",
    "text": "6.2 Load data\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\n\n# load object\nspe &lt;- Visium_humanDLPFC()"
  },
  {
    "objectID": "chapters/quality-control.html#plot-data",
    "href": "chapters/quality-control.html#plot-data",
    "title": "6  Quality control",
    "section": "6.3 Plot data",
    "text": "6.3 Plot data\nAs an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide, to check that the object has loaded correctly and that the orientation is as expected.\nWe use visualization functions from the ggspavis package to generate plots.\n\nlibrary(ggspavis)\n\n\n# plot spatial coordinates (spots)\nplotSpots(spe)"
  },
  {
    "objectID": "chapters/quality-control.html#calculate-qc-metrics",
    "href": "chapters/quality-control.html#calculate-qc-metrics",
    "title": "6  Quality control",
    "section": "6.4 Calculate QC metrics",
    "text": "6.4 Calculate QC metrics\nWe calculate the QC metrics described above with a combination of methods from the scater (McCarthy et al. 2017) package (for metrics that are also used for scRNA-seq data, where we treat spots as equivalent to cells) and our own functions.\nThe QC metrics from scater can be calculated and added to the SpatialExperiment object as follows. Here, we also identify mitochondrial reads using their gene names, and pass these as an argument to scater.\nFirst, we subset the object to keep only spots over tissue. The remaining spots are background spots, which we are not interested in.\n\nlibrary(scater)\n\n\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\ndim(spe)\n\n[1] 33538  3639\n\n\n\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\ntable(is_mito)\n\nis_mito\nFALSE  TRUE \n33525    13 \n\nrowData(spe)$gene_name[is_mito]\n\n [1] \"MT-ND1\"  \"MT-ND2\"  \"MT-CO1\"  \"MT-CO2\"  \"MT-ATP8\" \"MT-ATP6\" \"MT-CO3\" \n [8] \"MT-ND3\"  \"MT-ND4L\" \"MT-ND4\"  \"MT-ND5\"  \"MT-ND6\"  \"MT-CYB\" \n\n# calculate per-spot QC metrics and store in colData\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\nhead(colData(spe))\n\nDataFrame with 6 rows and 13 columns\n                           barcode_id     sample_id in_tissue array_row\n                          &lt;character&gt;   &lt;character&gt; &lt;integer&gt; &lt;integer&gt;\nAAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 sample_151673         1        50\nAAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 sample_151673         1         3\nAAACACCAATAACTGC-1 AAACACCAATAACTGC-1 sample_151673         1        59\nAAACAGAGCGACTCCT-1 AAACAGAGCGACTCCT-1 sample_151673         1        14\nAAACAGCTTTCAGAAG-1 AAACAGCTTTCAGAAG-1 sample_151673         1        43\nAAACAGGGTCTATATT-1 AAACAGGGTCTATATT-1 sample_151673         1        47\n                   array_col ground_truth cell_count       sum  detected\n                   &lt;integer&gt;  &lt;character&gt;  &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt;\nAAACAAGTATCTCCCA-1       102       Layer3          6      8458      3586\nAAACAATCTACTAGCA-1        43       Layer1         16      1667      1150\nAAACACCAATAACTGC-1        19           WM          5      3769      1960\nAAACAGAGCGACTCCT-1        94       Layer3          2      5433      2424\nAAACAGCTTTCAGAAG-1         9       Layer5          4      4278      2264\nAAACAGGGTCTATATT-1        13       Layer6          6      4004      2178\n                   subsets_mito_sum subsets_mito_detected subsets_mito_percent\n                          &lt;numeric&gt;             &lt;numeric&gt;            &lt;numeric&gt;\nAAACAAGTATCTCCCA-1             1407                    13              16.6351\nAAACAATCTACTAGCA-1              204                    11              12.2376\nAAACACCAATAACTGC-1              430                    13              11.4089\nAAACAGAGCGACTCCT-1             1316                    13              24.2223\nAAACAGCTTTCAGAAG-1              651                    12              15.2174\nAAACAGGGTCTATATT-1              621                    13              15.5095\n                       total\n                   &lt;numeric&gt;\nAAACAAGTATCTCCCA-1      8458\nAAACAATCTACTAGCA-1      1667\nAAACACCAATAACTGC-1      3769\nAAACAGAGCGACTCCT-1      5433\nAAACAGCTTTCAGAAG-1      4278\nAAACAGGGTCTATATT-1      4004"
  },
  {
    "objectID": "chapters/quality-control.html#selecting-thresholds",
    "href": "chapters/quality-control.html#selecting-thresholds",
    "title": "6  Quality control",
    "section": "6.5 Selecting thresholds",
    "text": "6.5 Selecting thresholds\nThe simplest option to apply the QC metrics is to select thresholds for each metric, and remove any spots that do not meet the thresholds for one or more metrics. Exploratory visualizations can be used to help select appropriate thresholds, which may differ depending on the dataset.\nHere, we use visualizations to select thresholds for several QC metrics in our human DLPFC dataset: (i) library size, (ii) number of expressed genes, (iii) proportion of mitochondrial reads, and (iv) number of cells per spot.\n\n6.5.1 Library size\nLibrary size represents the total sum of UMI counts per spot. This is included in the column labeled sum in the scater output.\nPlot a histogram of the library sizes across spots.\n\n# histogram of library sizes\nhist(colData(spe)$sum, breaks = 20)\n\n\n\n\nThe distribution is relatively smooth, and there are no obvious issue such as a spike at very low library sizes.\nWe also plot the library sizes against the number of cells per spot (which is available for this dataset). This is to check that we are not inadvertently removing a biologically meaningful group of spots. The horizontal line (argument threshold) shows our first guess at a possible filtering threshold for library size based on the histogram.\n\n# plot library size vs. number of cells per spot\nplotSpotQC(spe, plot_type = \"scatter\", \n           x_metric = \"cell_count\", y_metric = \"sum\", \n           y_threshold = 600)\n\n`geom_smooth()` using formula = 'y ~ x'\n`stat_xsidebin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_ysidebin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nThe plot shows that setting a filtering threshold for library size (e.g. at the value shown) does not appear to select for any obvious biologically consistent group of spots.\nWe set a relatively arbitrary threshold of 600 UMI counts per spot, and then check the number of spots below this threshold.\n\n# select QC threshold for library size\nqc_lib_size &lt;- colData(spe)$sum &lt; 600\ntable(qc_lib_size)\n\nqc_lib_size\nFALSE  TRUE \n 3631     8 \n\ncolData(spe)$qc_lib_size &lt;- qc_lib_size\n\nFinally, we also check that the discarded spots do not have any obvious spatial pattern that correlates with known biological features. Otherwise, removing these spots could indicate that we have set the threshold too high, and are removing biologically informative spots.\n\n# check spatial pattern of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_lib_size\")\n\n\n\n\nAs an aside, here we can also illustrate what happens if we set the threshold too high. For example, if we set the threshold to 2000 UMI counts per spot – which may also seem like a reasonable value based on the histogram and scatterplot – then we see a possible spatial pattern in the discarded spots, matching the cortical layers. This illustrates the importance of interactively checking exploratory visualizations when choosing these thresholds.\n\n# check spatial pattern of discarded spots if threshold is too high\nqc_lib_size_2000 &lt;- colData(spe)$sum &lt; 2000\ncolData(spe)$qc_lib_size_2000 &lt;- qc_lib_size_2000\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_lib_size_2000\")\n\n\n\n\nFor reference, here are the ground truth (manually annotated) cortical layers in this dataset.\n\n# plot ground truth (manually annotated) layers\nplotSpots(spe, annotate = \"ground_truth\", \n          pal = \"libd_layer_colors\")\n\n\n\n\n\n\n6.5.2 Number of expressed features\nThe number of expressed features refers to the number of genes with non-zero UMI counts per spot. This is stored in the column detected in the scater output.\nWe use a similar sequence of visualizations to choose a threshold for this QC metric.\n\n# histogram of numbers of expressed genes\nhist(colData(spe)$detected, breaks = 20)\n\n\n\n\n\n# plot number of expressed genes vs. number of cells per spot\nplotSpotQC(spe, plot_type = \"scatter\", \n           x_metric = \"cell_count\", y_metric = \"detected\", \n           y_threshold = 400)\n\n`geom_smooth()` using formula = 'y ~ x'\n`stat_xsidebin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_ysidebin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nBased on the plots, we select a threshold of 400 expressed genes per spot.\n\n# select QC threshold for number of expressed genes\nqc_detected &lt;- colData(spe)$detected &lt; 400\ntable(qc_detected)\n\nqc_detected\nFALSE  TRUE \n 3632     7 \n\ncolData(spe)$qc_detected &lt;- qc_detected\n\n\n# check spatial pattern of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_detected\")\n\n\n\n\nAgain, we also check what happens when we set the threshold too high.\n\n# check spatial pattern of discarded spots if threshold is too high\nqc_detected_1000 &lt;- colData(spe)$detected &lt; 1000\ncolData(spe)$qc_detected_1000 &lt;- qc_detected_1000\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_detected_1000\")\n\n\n\n\n\n\n6.5.3 Proportion of mitochondrial reads\nA high proportion of mitochondrial reads indicates cell damage.\nWe investigate the proportions of mitochondrial reads across spots, and select an appropriate threshold. The proportions of mitochondrial reads per spot are stored in the column subsets_mito_percent in the scater output.\n\n# histogram of mitochondrial read proportions\nhist(colData(spe)$subsets_mito_percent, breaks = 20)\n\n\n\n\n\n# plot mitochondrial read proportion vs. number of cells per spot\nplotSpotQC(spe, plot_type = \"scatter\", \n           x_metric = \"cell_count\", y_metric = \"subsets_mito_percent\", \n           y_threshold = 28)\n\n`geom_smooth()` using formula = 'y ~ x'\n`stat_xsidebin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_ysidebin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nWe select a threshold of 28% for the mitochondrial read proportion.\n\n# select QC threshold for mitochondrial read proportion\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 28\ntable(qc_mito)\n\nqc_mito\nFALSE  TRUE \n 3622    17 \n\ncolData(spe)$qc_mito &lt;- qc_mito\n\n\n# check spatial pattern of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_mito\")\n\n\n\n\nWe also check what happens when we set the threshold too low.\n\n# check spatial pattern of discarded spots if threshold is too high\nqc_mito_25 &lt;- colData(spe)$subsets_mito_percent &gt; 25\ncolData(spe)$qc_mito_25 &lt;- qc_mito_25\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_mito_25\")\n\n\n\n\n\n\n6.5.4 Number of cells per spot\nThe number of cells per spot depends on the tissue type and organism.\nHere, we check for any outlier values that could indicate problems during cell segmentation.\n\n# histogram of cell counts\nhist(colData(spe)$cell_count, breaks = 20)\n\n\n\n# distribution of cells per spot\ntbl_cells_per_spot &lt;- table(colData(spe)$cell_count)\n\nWe see a tail of very high values, which could indicate problems for these spots. These values are also visible on the scatterplots. Here, we again plot the number of expressed genes vs. cell count, with an added trend.\n\n# plot number of expressed genes vs. number of cells per spot\nplotSpotQC(spe, plot_type = \"scatter\", \n           x_metric = \"cell_count\", y_metric = \"detected\", \n           x_threshold = 10)\n\n`geom_smooth()` using formula = 'y ~ x'\n`stat_xsidebin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_ysidebin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nIn particular, we see that the spots with very high cell counts also have low numbers of expressed genes. This indicates that the experiments have failed for these spots, and they should be removed.\nWe select a threshold of 10 cells per spot. The number of spots above this threshold is relatively small, and there is a clear downward trend in the number of expressed genes above this threshold.\n\n# select QC threshold for number of cells per spot\nqc_cell_count &lt;- colData(spe)$cell_count &gt; 10\ntable(qc_cell_count)\n\nqc_cell_count\nFALSE  TRUE \n 3549    90 \n\ncolData(spe)$qc_cell_count &lt;- qc_cell_count\n\n\n# check spatial pattern of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"qc_cell_count\")\n\n\n\n\nWhile there is a spatial pattern to the discarded spots, it does not appear to be correlated with the known biological features (cortical layers). The discarded spots are all on the edges of the tissue. It seems plausible that something has gone wrong with the cell segmentation on the edges of the images, so it makes sense to remove these spots.\n\n\n6.5.5 Remove low-quality spots\nNow that we have calculated several QC metrics and selected thresholds for each one, we can combine the sets of low-quality spots, and remove them from our object.\nWe also check again that the combined set of discarded spots does not correspond to any obvious biologically relevant group of spots.\n\n# number of discarded spots for each metric\napply(cbind(qc_lib_size, qc_detected, qc_mito, qc_cell_count), 2, sum)\n\n  qc_lib_size   qc_detected       qc_mito qc_cell_count \n            8             7            17            90 \n\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count\ntable(discard)\n\ndiscard\nFALSE  TRUE \n 3524   115 \n\n# store in object\ncolData(spe)$discard &lt;- discard\n\n\n# check spatial pattern of combined set of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", \n           annotate = \"discard\")\n\n\n\n\n\n# remove combined set of low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]\ndim(spe)\n\n[1] 33538  3524"
  },
  {
    "objectID": "chapters/quality-control.html#zero-cell-and-single-cell-spots",
    "href": "chapters/quality-control.html#zero-cell-and-single-cell-spots",
    "title": "6  Quality control",
    "section": "6.6 Zero-cell and single-cell spots",
    "text": "6.6 Zero-cell and single-cell spots\nA particular characteristic of Visium data is that spots can contain zero, one, or multiple cells.\nWe could also imagine other filtering procedures such as (i) removing spots with zero cells, or (ii) restricting the analysis to spots containing a single cell (which would make the data more similar to scRNA-seq).\nHowever, this would discard a large amount of information. Below, we show the distribution of cells per spot again (up to the filtering threshold of 10 cells per spot from above).\n\n# distribution of cells per spot\ntbl_cells_per_spot[1:13]\n\n\n  0   1   2   3   4   5   6   7   8   9  10  11  12 \n 84 211 483 623 617 541 421 287 140  92  50  25  18 \n\n# as proportions\nprop_cells_per_spot &lt;- round(tbl_cells_per_spot / sum(tbl_cells_per_spot), 2)\nprop_cells_per_spot[1:13]\n\n\n   0    1    2    3    4    5    6    7    8    9   10   11   12 \n0.02 0.06 0.13 0.17 0.17 0.15 0.12 0.08 0.04 0.03 0.01 0.01 0.00 \n\n\nOnly 6% of spots contain a single cell. If we restricted the analysis to these spots only, we would be discarding most of the data.\nRemoving the spots containing zero cells (2% of spots) would also be problematic, since these spots can also contain biologically meaningful information. For example, in this brain dataset, the regions between cell bodies consists of neuropil (dense networks of axons and dendrites). In our paper (Maynard et al. 2021), we explore the information contained in these neuropil spots."
  },
  {
    "objectID": "chapters/quality-control.html#quality-control-at-gene-level",
    "href": "chapters/quality-control.html#quality-control-at-gene-level",
    "title": "6  Quality control",
    "section": "6.7 Quality control at gene level",
    "text": "6.7 Quality control at gene level\nThe sections above consider quality control at the spot level. In some datasets, it may also be appropriate to apply quality control procedures or filtering at the gene level. For example, certain genes may be biologically irrelevant for downstream analyses.\nHowever, here we make a distinction between quality control and feature selection. Removing biologically uninteresting genes (such as mitochondrial genes) may also be considered as part of feature selection, since there is no underlying experimental procedure that has failed. Therefore, we will discuss gene-level filtering in the Chapter 8 chapter.\n\n\n\n\nMaynard, Kristen R., Leonardo Collado-Torres, Lukas M. Weber, Cedric Uytingco, Brianna K. Barry, Stephen R. Williams, Joseph L. Catallini II, et al. 2021. “Transcriptome-Scale Spatial Gene Expression in the Human Dorsolateral Prefrontal Cortex.” Nature Neuroscience 24: 425–36. https://doi.org/10.1038/s41593-020-00787-0.\n\n\nMcCarthy, Davis J., Kieran R. Campbell, Aaron T. L. Lun, and Quin F. Wills. 2017. “Scater: Pre-Processing, Quality Control, Normalization and Visualization of Single-Cell RNA-seq Data in R.” Bioinformatics 33 (8): 1179–86. https://doi.org/10.1093/bioinformatics/btw777."
  },
  {
    "objectID": "chapters/normalization.html#overview",
    "href": "chapters/normalization.html#overview",
    "title": "7  Normalization",
    "section": "7.1 Overview",
    "text": "7.1 Overview\nHere we apply normalization methods developed for scRNA-seq data, treating each spot as equivalent to one cell."
  },
  {
    "objectID": "chapters/normalization.html#previous-steps",
    "href": "chapters/normalization.html#previous-steps",
    "title": "7  Normalization",
    "section": "7.2 Previous steps",
    "text": "7.2 Previous steps\nCode to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter.\n\n# LOAD DATA\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\nspe &lt;- Visium_humanDLPFC()\n\n# QUALITY CONTROL (QC)\n\nlibrary(scater)\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\n# calculate per-spot QC metrics\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\n# select QC thresholds\nqc_lib_size &lt;- colData(spe)$sum &lt; 600\nqc_detected &lt;- colData(spe)$detected &lt; 400\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 28\nqc_cell_count &lt;- colData(spe)$cell_count &gt; 10\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count\ncolData(spe)$discard &lt;- discard\n# filter low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]"
  },
  {
    "objectID": "chapters/normalization.html#logcounts",
    "href": "chapters/normalization.html#logcounts",
    "title": "7  Normalization",
    "section": "7.3 Logcounts",
    "text": "7.3 Logcounts\nCalculate log-transformed normalized counts (abbreviated as “logcounts”) using library size factors.\nWe apply the methods implemented in the scater (McCarthy et al. 2017) and scran (Lun, McCarthy, and Marioni 2016) packages, which were originally developed for scRNA-seq data, making the assumption here that these methods can be applied to SRT data by treating spots as equivalent to cells.\nWe use the library size factors methodology since this is the simplest approach, and can easily be applied to SRT data. Alternative approaches that are populare for scRNA-seq data, including normalization by deconvolution, are more difficulty to justify in the context of spot-based SRT data since (i) spots may contain multiple cells from more than one cell type, and (ii) datasets can contain multiple samples (e.g. multiple Visium slides, resulting in sample-specific clustering).\n\nlibrary(scran)\n\n# calculate library size factors\nspe &lt;- computeLibraryFactors(spe)\n\nsummary(sizeFactors(spe))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.1321  0.6312  0.9000  1.0000  1.2849  3.7582 \n\nhist(sizeFactors(spe), breaks = 20)\n\n\n\n# calculate logcounts and store in object\nspe &lt;- logNormCounts(spe)\n\n# check\nassayNames(spe)\n\n[1] \"counts\"    \"logcounts\"\n\ndim(counts(spe))\n\n[1] 33538  3524\n\ndim(logcounts(spe))\n\n[1] 33538  3524\n\n\n\n\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. “A Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.” F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2.\n\n\nMcCarthy, Davis J., Kieran R. Campbell, Aaron T. L. Lun, and Quin F. Wills. 2017. “Scater: Pre-Processing, Quality Control, Normalization and Visualization of Single-Cell RNA-seq Data in R.” Bioinformatics 33 (8): 1179–86. https://doi.org/10.1093/bioinformatics/btw777."
  },
  {
    "objectID": "chapters/feature-selection.html#overview",
    "href": "chapters/feature-selection.html#overview",
    "title": "8  Feature selection",
    "section": "8.1 Overview",
    "text": "8.1 Overview\nHere we apply feature selection methods to identify highly variable genes (HVGs) or spatially variable genes (SVGs), which can then be investigated individually or used as the input for further downstream analyses such as clustering."
  },
  {
    "objectID": "chapters/feature-selection.html#previous-steps",
    "href": "chapters/feature-selection.html#previous-steps",
    "title": "8  Feature selection",
    "section": "8.2 Previous steps",
    "text": "8.2 Previous steps\nCode to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter.\n\n# LOAD DATA\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\nspe &lt;- Visium_humanDLPFC()\n\n# QUALITY CONTROL (QC)\n\nlibrary(scater)\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\n# calculate per-spot QC metrics\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\n# select QC thresholds\nqc_lib_size &lt;- colData(spe)$sum &lt; 600\nqc_detected &lt;- colData(spe)$detected &lt; 400\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 28\nqc_cell_count &lt;- colData(spe)$cell_count &gt; 10\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count\ncolData(spe)$discard &lt;- discard\n# filter low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]\n\n# NORMALIZATION\n\nlibrary(scran)\n# calculate logcounts using library size factors\nspe &lt;- logNormCounts(spe)"
  },
  {
    "objectID": "chapters/feature-selection.html#highly-variable-genes-hvgs",
    "href": "chapters/feature-selection.html#highly-variable-genes-hvgs",
    "title": "8  Feature selection",
    "section": "8.3 Highly variable genes (HVGs)",
    "text": "8.3 Highly variable genes (HVGs)\nWe use methods from scran (Lun, McCarthy, and Marioni 2016) to identify a set of top highly variable genes (HVGs), which can be used to define major cell types. These methods were originally developed for single-cell RNA sequencing (scRNA-seq) data, so here we are making the assumption that spots can be treated as equivalent to cells.\nNote that HVGs are defined based only on molecular features (i.e. gene expression), and do not take any spatial information into account. If the biologically meaningful spatial information in this dataset mainly reflects spatial distributions of cell types, then relying on HVGs for downstream analyses may be sufficient. However, many datasets contain further spatial structure that is not captured in this way, which may be investigated using spatially-aware methods such as identifying spatially variable genes (SVGs).\nTo identify HVGs, we first remove mitochondrial genes, since these are very highly expressed in this dataset and are not of main biological interest.\n\n# remove mitochondrial genes\nspe &lt;- spe[!is_mito, ]\ndim(spe)\n\n[1] 33525  3524\n\n\nThen, we apply methods from scran. This gives us a list of HVGs, which can be used for further downstream analyses. The parameter prop defines how many HVGs we want. For example prop = 0.1 returns the top 10% of genes.\n\nlibrary(scran)\n\n# fit mean-variance relationship\ndec &lt;- modelGeneVar(spe)\n\n# visualize mean-variance relationship\nfit &lt;- metadata(dec)\nplot(fit$mean, fit$var, \n     xlab = \"mean of log-expression\", ylab = \"variance of log-expression\")\ncurve(fit$trend(x), col = \"dodgerblue\", add = TRUE, lwd = 2)\n\n\n\n# select top HVGs\ntop_hvgs &lt;- getTopHVGs(dec, prop = 0.1)\nlength(top_hvgs)\n\n[1] 1438"
  },
  {
    "objectID": "chapters/feature-selection.html#spatially-variable-genes-svgs",
    "href": "chapters/feature-selection.html#spatially-variable-genes-svgs",
    "title": "8  Feature selection",
    "section": "8.4 Spatially variable genes (SVGs)",
    "text": "8.4 Spatially variable genes (SVGs)\nAlternatively, we can apply methods to identify spatially variable genes (SVGs) instead of HVGs. Here, we define SVGs as any genes with spatially correlated patterns of expression across the tissue area.\nSeveral methods to identify SVGs in ST data have recently been developed, which each have various methodological and computational tradeoffs. These include:\n\nnnSVG: available as an R package from Bioconductor and described by Weber et al. (2023)\nSPARK-X: available as an R package from GitHub and described by Zhu, Sun, and Zhou (2021)\nSPARK: available as an R package from GitHub and described by Sun, Zhu, and Zhou (2020)\nSpatialDE: available as a Python package from GitHub and described by Svensson, Teichmann, and Stegle (2018)\n\nAlternatively, standard statistical metrics such as Moran’s I statistic or Geary’s C statistic may also be used to rank genes by their observed spatial autocorrelation. However, the methods above tend to be more sensitive, since they have been developed for the specific properties of ST data.\n\n8.4.1 nnSVG\nHere, we demonstrate a short example showing how to identify a set of top SVGs using nnSVG (Weber et al. 2023). This method is available in Bioconductor and can be easily integrated into Bioconductor-based workflows.\nIn this example, we run nnSVG using a small subset of the dataset for faster runtime. We select a subset by subsampling on the set of spots and including stringent filtering for low-expressed genes. A full analysis using all spots for this dataset and default filtering parameters for Visium data from human brain tissue takes around 45 minutes for one Visium sample on a standard laptop.\n\nlibrary(nnSVG)\n\n\n# subsample spots for faster runtime in this example\n# note: skip this step in full analysis\nn &lt;- 100\nset.seed(123)\nix &lt;- sample(seq_len(n), n)\nspe_nnSVG &lt;- spe[, ix]\n\n# filter low-expressed and mitochondrial genes\n# using stringent filtering for faster runtime in this example\n# note: use default filtering in full analysis\nspe_nnSVG &lt;- filter_genes(\n  spe_nnSVG, filter_genes_ncounts = 10, filter_genes_pcspots = 3\n)\n\nGene filtering: removing mitochondrial genes\n\n\nremoved 0 mitochondrial genes\n\n\nGene filtering: retaining genes with at least 10 counts in at least 3% (n = 3) of spatial locations\n\n\nremoved 33353 out of 33525 genes due to low expression\n\n# re-calculate logcounts after filtering\nspe_nnSVG &lt;- logNormCounts(spe_nnSVG)\n\n\n# run nnSVG\nset.seed(123)\nspe_nnSVG &lt;- nnSVG(spe_nnSVG)\n\n\n# investigate results\n\n# show results\nhead(rowData(spe_nnSVG), 3)\n\nDataFrame with 3 rows and 17 columns\n                        gene_id   gene_name    feature_type   sigma.sq\n                    &lt;character&gt; &lt;character&gt;     &lt;character&gt;  &lt;numeric&gt;\nENSG00000074800 ENSG00000074800        ENO1 Gene Expression 0.00840777\nENSG00000171603 ENSG00000171603      CLSTN1 Gene Expression 0.43102027\nENSG00000162545 ENSG00000162545     CAMK2N1 Gene Expression 0.15373440\n                   tau.sq       phi    loglik   runtime      mean       var\n                &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSG00000074800  0.518011  15.82454  -109.808     0.018   1.75820  0.530929\nENSG00000171603  0.298698  18.12310  -123.212     0.023   2.07433  0.741077\nENSG00000162545  0.547736   2.38046  -119.576     0.016   2.63576  0.702846\n                    spcov   prop_sv loglik_lm   LR_stat      rank      pval\n                &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSG00000074800 0.0521523 0.0159716  -109.735 -0.145454       167 1.0000000\nENSG00000171603 0.3164987 0.5906665  -126.409  6.394009        86 0.0408845\nENSG00000162545 0.1487576 0.2191603  -123.760  8.368951        70 0.0152302\n                     padj\n                &lt;numeric&gt;\nENSG00000074800 1.0000000\nENSG00000171603 0.0817690\nENSG00000162545 0.0374227\n\n# number of significant SVGs\ntable(rowData(spe_nnSVG)$padj &lt;= 0.05)\n\n\nFALSE  TRUE \n   96    76 \n\n# show results for top n SVGs\nrowData(spe_nnSVG)[order(rowData(spe_nnSVG)$rank)[1:6], ]\n\nDataFrame with 6 rows and 17 columns\n                        gene_id   gene_name    feature_type  sigma.sq    tau.sq\n                    &lt;character&gt; &lt;character&gt;     &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSG00000197971 ENSG00000197971         MBP Gene Expression   3.92430  0.175336\nENSG00000123560 ENSG00000123560        PLP1 Gene Expression   3.23544  0.461590\nENSG00000109846 ENSG00000109846       CRYAB Gene Expression   1.89968  0.281795\nENSG00000173786 ENSG00000173786         CNP Gene Expression   2.28793  0.402524\nENSG00000131095 ENSG00000131095        GFAP Gene Expression   2.23709  0.461297\nENSG00000160307 ENSG00000160307       S100B Gene Expression   1.24179  0.155737\n                      phi    loglik   runtime      mean       var     spcov\n                &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSG00000197971   0.93014  -118.372     0.021   3.78073   2.76535  0.523969\nENSG00000123560   1.03983  -140.269     0.019   2.86143   3.02555  0.628613\nENSG00000109846   1.88555  -126.692     0.017   1.86058   1.88123  0.740785\nENSG00000173786   1.02675  -129.206     0.017   1.79558   1.97274  0.842396\nENSG00000131095   2.49083  -149.004     0.019   1.94543   2.71281  0.768823\nENSG00000160307   5.76279  -129.722     0.015   1.82695   1.46946  0.609953\n                  prop_sv loglik_lm   LR_stat      rank        pval        padj\n                &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;   &lt;numeric&gt;   &lt;numeric&gt;\nENSG00000197971  0.957231  -192.250  147.7556         1 0.00000e+00 0.00000e+00\nENSG00000123560  0.875146  -196.746  112.9549         2 0.00000e+00 0.00000e+00\nENSG00000109846  0.870824  -172.988   92.5906         3 0.00000e+00 0.00000e+00\nENSG00000173786  0.850388  -175.363   92.3137         4 0.00000e+00 0.00000e+00\nENSG00000131095  0.829047  -191.291   84.5739         5 0.00000e+00 0.00000e+00\nENSG00000160307  0.888562  -160.636   61.8281         6 3.75255e-14 1.07573e-12\n\n# identify top-ranked SVG\nrowData(spe_nnSVG)$gene_name[which(rowData(spe_nnSVG)$rank == 1)]\n\n[1] \"MBP\"\n\n\n\n\n8.4.2 Downstream analyses\nThe set of top SVGs from nnSVG may then be investigated further, e.g. by plotting the spatial expression of several top genes and by comparing the list of top genes with known gene sets associated with biological processes of interest in the dataset. The set of top SVGs may also be used as the input for further downstream analyses such as spatially-aware clustering to define spatial domains (see Chapter 10).\n\n\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. “A Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.” F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2.\n\n\nSun, Shiquan, Jiaqiang Zhu, and Xiang Zhou. 2020. “Statistical Analysis of Spatial Expression Patterns for Spatially Resolved Transcriptomic Studies.” Nature Methods 17: 193–200. https://doi.org/10.1038/s41592-019-0701-7.\n\n\nSvensson, Valentine, Sarah A. Teichmann, and Oliver Stegle. 2018. “SpatialDE: Identification of Spatially Variable Genes.” Nature Methods 15: 343–46. https://doi.org/10.1038/nmeth.4636.\n\n\nWeber, Lukas M., Arkajyoti Saha, Abhirup Datta, Kasper D. Hansen, and Stephanie C. Hicks. 2023. “nnSVG for the Scalable Identification of Spatially Variable Genes Using Nearest-Neighbor Gaussian Processes.” Nature Communications 14: 4059. https://doi.org/10.1038/s41467-023-39748-z.\n\n\nZhu, Jiaqiang, Shiquan Sun, and Xiang Zhou. 2021. “SPARK-X: Non-Parametric Modeling Enables Scalable and Robust Detection of Spatial Expression Patterns for Large Spatial Transcriptomic Studies.” Genome Biology 22: 184. https://doi.org/10.1186/s13059-021-02404-0."
  },
  {
    "objectID": "chapters/dimensionality-reduction.html#overview",
    "href": "chapters/dimensionality-reduction.html#overview",
    "title": "9  Dimensionality reduction",
    "section": "9.1 Overview",
    "text": "9.1 Overview\nIn this chapter, we apply dimensionality reduction methods to visualize the data and to generate inputs for further downstream analyses."
  },
  {
    "objectID": "chapters/dimensionality-reduction.html#previous-steps",
    "href": "chapters/dimensionality-reduction.html#previous-steps",
    "title": "9  Dimensionality reduction",
    "section": "9.2 Previous steps",
    "text": "9.2 Previous steps\nCode to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter.\n\n# LOAD DATA\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\nspe &lt;- Visium_humanDLPFC()\n\n# QUALITY CONTROL (QC)\n\nlibrary(scater)\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\n# calculate per-spot QC metrics\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\n# select QC thresholds\nqc_lib_size &lt;- colData(spe)$sum &lt; 600\nqc_detected &lt;- colData(spe)$detected &lt; 400\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 28\nqc_cell_count &lt;- colData(spe)$cell_count &gt; 10\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count\ncolData(spe)$discard &lt;- discard\n# filter low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]\n\n# NORMALIZATION\n\nlibrary(scran)\n# calculate logcounts using library size factors\nspe &lt;- logNormCounts(spe)\n\n# FEATURE SELECTION\n\n# remove mitochondrial genes\nspe &lt;- spe[!is_mito, ]\n# fit mean-variance relationship\ndec &lt;- modelGeneVar(spe)\n# select top HVGs\ntop_hvgs &lt;- getTopHVGs(dec, prop = 0.1)"
  },
  {
    "objectID": "chapters/dimensionality-reduction.html#principal-component-analysis-pca",
    "href": "chapters/dimensionality-reduction.html#principal-component-analysis-pca",
    "title": "9  Dimensionality reduction",
    "section": "9.3 Principal component analysis (PCA)",
    "text": "9.3 Principal component analysis (PCA)\nApply principal component analysis (PCA) to the set of top highly variable genes (HVGs) to reduce the dimensionality of the dataset, and retain the top 50 principal components (PCs) for further downstream analyses.\nThis is done for two reasons: (i) to reduce noise due to random variation in expression of biologically uninteresting genes, which are assumed to have expression patterns that are independent of each other, and (ii) to improve computational efficiency during downstream analyses.\nWe use the computationally efficient implementation of PCA provided in the scater package (McCarthy et al. 2017). This implementation uses randomization, and therefore requires setting a random seed for reproducibility.\n\n# compute PCA\nset.seed(123)\nspe &lt;- runPCA(spe, subset_row = top_hvgs)\n\nreducedDimNames(spe)\n\n[1] \"PCA\"\n\ndim(reducedDim(spe, \"PCA\"))\n\n[1] 3524   50"
  },
  {
    "objectID": "chapters/dimensionality-reduction.html#uniform-manifold-approximation-and-projection-umap",
    "href": "chapters/dimensionality-reduction.html#uniform-manifold-approximation-and-projection-umap",
    "title": "9  Dimensionality reduction",
    "section": "9.4 Uniform Manifold Approximation and Projection (UMAP)",
    "text": "9.4 Uniform Manifold Approximation and Projection (UMAP)\nWe also run UMAP on the set of top 50 PCs and retain the top 2 UMAP components, which will be used for visualization purposes.\n\n# compute UMAP on top 50 PCs\nset.seed(123)\nspe &lt;- runUMAP(spe, dimred = \"PCA\")\n\nreducedDimNames(spe)\n\n[1] \"PCA\"  \"UMAP\"\n\ndim(reducedDim(spe, \"UMAP\"))\n\n[1] 3524    2\n\n# update column names for easier plotting\ncolnames(reducedDim(spe, \"UMAP\")) &lt;- paste0(\"UMAP\", 1:2)"
  },
  {
    "objectID": "chapters/dimensionality-reduction.html#visualizations",
    "href": "chapters/dimensionality-reduction.html#visualizations",
    "title": "9  Dimensionality reduction",
    "section": "9.5 Visualizations",
    "text": "9.5 Visualizations\nGenerate plots using plotting functions from the ggspavis package. In the next chapter on clustering, we will add cluster labels to these reduced dimension plots.\n\nlibrary(ggspavis)\n\n\n# plot top 2 PCA dimensions\nplotDimRed(spe, plot_type = \"PCA\")\n\n\n\n# plot top 2 UMAP dimensions\nplotDimRed(spe, plot_type = \"UMAP\")\n\n\n\n\n\n\n\n\nMcCarthy, Davis J., Kieran R. Campbell, Aaron T. L. Lun, and Quin F. Wills. 2017. “Scater: Pre-Processing, Quality Control, Normalization and Visualization of Single-Cell RNA-seq Data in R.” Bioinformatics 33 (8): 1179–86. https://doi.org/10.1093/bioinformatics/btw777."
  },
  {
    "objectID": "chapters/clustering.html#overview",
    "href": "chapters/clustering.html#overview",
    "title": "10  Clustering",
    "section": "10.1 Overview",
    "text": "10.1 Overview\nIn ST data, we can apply clustering algorithms to identify ‘spatial domains’, which represent spatially defined regions consisting of relatively consistent gene expression profiles. For example, spatial domains may consist of regions containing cells from a single cell type or a consistent mixture of cell types.\nSeveral alternative approaches exist for these analyses. For example, we can apply standard clustering algorithms from single-cell workflows to identify cell types without taking any spatial information into account, and then analyze the spatial distributions of these cell types. Alternatively, we can use spatially-aware clustering algorithms that directly take the spatial coordinates of the measurements into account. For larger datasets, there may also be important computational tradeoffs between the various approaches.\nIt is also important to keep in mind that when we use clustering to define cell types and/or states, these can be defined at various resolutions (or even on a continuum). The optimal number of clusters depends on the biological context – in particular, there is no “true” number of clusters, since this depends on the biological context (e.g. if we are comparing major cell populations vs. comparing rare subtypes), so the choice of the optimal number of clusters requires some judgment and biological interpretation.\nOnce we have identified spatial domains, these can then be further investigated in additional downstream analyses."
  },
  {
    "objectID": "chapters/clustering.html#previous-steps",
    "href": "chapters/clustering.html#previous-steps",
    "title": "10  Clustering",
    "section": "10.2 Previous steps",
    "text": "10.2 Previous steps\nCode to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter.\n\n# LOAD DATA\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\nspe &lt;- Visium_humanDLPFC()\n\n# QUALITY CONTROL (QC)\n\nlibrary(scater)\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\n# calculate per-spot QC metrics\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\n# select QC thresholds\nqc_lib_size &lt;- colData(spe)$sum &lt; 600\nqc_detected &lt;- colData(spe)$detected &lt; 400\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 28\nqc_cell_count &lt;- colData(spe)$cell_count &gt; 10\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count\ncolData(spe)$discard &lt;- discard\n# filter low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]\n\n# NORMALIZATION\n\nlibrary(scran)\n# calculate logcounts using library size factors\nspe &lt;- logNormCounts(spe)\n\n\n# note: store object for later\nspe_full &lt;- spe\n\n\n# FEATURE SELECTION\n\n# remove mitochondrial genes\nspe &lt;- spe[!is_mito, ]\n# fit mean-variance relationship\ndec &lt;- modelGeneVar(spe)\n# select top HVGs\ntop_hvgs &lt;- getTopHVGs(dec, prop = 0.1)\n\n# DIMENSIONALITY REDUCTION\n\n# compute PCA\nset.seed(123)\nspe &lt;- runPCA(spe, subset_row = top_hvgs)\n# compute UMAP on top 50 PCs\nset.seed(123)\nspe &lt;- runUMAP(spe, dimred = \"PCA\")\n# update column names\ncolnames(reducedDim(spe, \"UMAP\")) &lt;- paste0(\"UMAP\", 1:2)"
  },
  {
    "objectID": "chapters/clustering.html#non-spatial-clustering",
    "href": "chapters/clustering.html#non-spatial-clustering",
    "title": "10  Clustering",
    "section": "10.3 Non-spatial clustering",
    "text": "10.3 Non-spatial clustering\n\n10.3.1 Clustering using HVGs\nHere, we perform clustering by applying standard clustering methods developed for single-cell RNA sequencing data, using molecular features (gene expression) only. We apply graph-based clustering using the Walktrap method implemented in scran (Lun, McCarthy, and Marioni 2016), applied to the top 50 PCs calculated on the set of top HVGs.\nIn the context of spatial data, this is the same as applying clustering to identify cell types in single-cell data (although each spot may contain one or more cells, depending on the platform and tissue cell density), and means that we are assuming that biologically informative spatial distribution patterns of cell types can be detected from the molecular features (gene expression).\n\n# graph-based clustering\nset.seed(123)\nk &lt;- 10\ng &lt;- buildSNNGraph(spe, k = k, use.dimred = \"PCA\")\ng_walk &lt;- igraph::cluster_walktrap(g)\nclus &lt;- g_walk$membership\ntable(clus)\n\nclus\n   1    2    3    4    5    6    7 \n 338  312 1146  978  274  116  360 \n\n# store cluster labels in column 'label' in colData\ncolLabels(spe) &lt;- factor(clus)\n\nVisualize the clusters by plotting in (i) spatial (x-y) coordinates on the tissue slide, and (ii) reduced dimension space (PCA or UMAP). We use plotting functions from the ggspavis package.\nFor reference, we also display the ground truth (manually annotated) labels available for this dataset (in spatial coordinates).\nFrom the visualizations, we can see that the clustering reproduces the known biological structure (cortical layers), although not perfectly. The clusters are also separated in UMAP space, but again not perfectly.\n\nlibrary(ggspavis)\n\n\n# plot clusters in spatial x-y coordinates\nplotSpots(spe, annotate = \"label\", \n          pal = \"libd_layer_colors\")\n\n\n\n# plot ground truth labels in spatial coordinates\nplotSpots(spe, annotate = \"ground_truth\", \n          pal = \"libd_layer_colors\")\n\n\n\n\n\n# plot clusters in PCA reduced dimensions\nplotDimRed(spe, plot_type = \"PCA\", \n           annotate = \"label\", pal = \"libd_layer_colors\")\n\n\n\n# plot clusters in UMAP reduced dimensions\nplotDimRed(spe, plot_type = \"UMAP\", \n           annotate = \"label\", pal = \"libd_layer_colors\")"
  },
  {
    "objectID": "chapters/clustering.html#spatially-aware-clustering",
    "href": "chapters/clustering.html#spatially-aware-clustering",
    "title": "10  Clustering",
    "section": "10.4 Spatially-aware clustering",
    "text": "10.4 Spatially-aware clustering\nThe example above shows that non-spatial clustering can capture some spatial relationships in ST data, primarily if these are due to spatially distributed cell types and where the cell types can be identified from their gene expression profiles alone. However, this does not directly make use of the spatial information contained in the measurements.\nIn many ST datasets, we can uncover further structure by performing analyses that directly take spatial information into account. Below, we demonstrate examples of these types of analyses, which we refer to as ‘spatially-aware clustering’.\n\n10.4.1 Clustering using SVGs\nOne way to perform spatially-aware clustering is to first perform spatially-aware feature selection to identify a set of top spatially variable genes (SVGs) (see Chapter 8) and then use the set of top SVGs as the input for clustering.\nIn this case, the spatial information is taken into account during the feature selection stage, where we select a set of top SVGs instead of top HVGs. For the clustering stage, we can use the same algorithms as for non-spatial clustering.\nHere, we demonstrate an example using nnSVG (Weber et al. 2023) to select the set of top SVGs. Note that in this example, we run nnSVG using a small subset of the dataset for faster runtime. For a full analysis, the full dataset should be used (see Chapter 8 for more details).\n\nlibrary(nnSVG)\n\n\n# subsample spots for faster runtime in this example\n# note: skip this step in full analysis\nn &lt;- 100\nset.seed(123)\nix &lt;- sample(seq_len(n), n)\nspe_nnSVG &lt;- spe_full[, ix]  ## note: using full object\n\n# filter low-expressed and mitochondrial genes\n# using stringent filtering for faster runtime in this example\n# note: use default filtering in full analysis\nspe_nnSVG &lt;- filter_genes(\n  spe_nnSVG, filter_genes_ncounts = 10, filter_genes_pcspots = 3\n)\n\nGene filtering: removing mitochondrial genes\n\n\nremoved 13 mitochondrial genes\n\n\nGene filtering: retaining genes with at least 10 counts in at least 3% (n = 3) of spatial locations\n\n\nremoved 33353 out of 33525 genes due to low expression\n\n# re-calculate logcounts after filtering\nspe_nnSVG &lt;- logNormCounts(spe_nnSVG)\n\n\n# run nnSVG\nset.seed(123)\nspe_nnSVG &lt;- nnSVG(spe_nnSVG)\n\nNow that we have run nnSVG, we can select at set of top SVGs (instead of HVGs), and use these as the input for the subsequent clustering steps.\n\n# select top SVGs\n# note: using small subset in this example\n# use larger set (e.g. top 1000 genes) in full analysis\nn_top &lt;- 50\nix_top &lt;- order(rowData(spe_nnSVG)$rank)[1:n]\ntop_svgs &lt;- rowData(spe_nnSVG)[ix_top, \"gene_id\"]\n\n\n# dimensionality reduction\n# compute PCA\n# note: using small number of components in this example\n# use larger number (e.g. ncomponents = 50) in full analysis\nset.seed(123)\nspe_nnSVG &lt;- runPCA(spe_nnSVG, ncomponents = 10, subset_row = top_svgs)\n\n\n# graph-based clustering\nset.seed(123)\nk &lt;- 10\ng &lt;- buildSNNGraph(spe_nnSVG, k = k, use.dimred = \"PCA\")\ng_walk &lt;- igraph::cluster_walktrap(g)\nclus &lt;- g_walk$membership\ntable(clus)\n\nclus\n 1  2  3  4  5 \n 6  6 53 24 11 \n\n# store cluster labels in column 'label' in colData\ncolLabels(spe_nnSVG) &lt;- factor(clus)\n\n\n\n10.4.2 Clustering using concatenated features\nAn alternative strategy is to perform clustering on a set of concatenated columns of non-spatial and spatial features. For example, we can concatenate columns of non-spatial molecular features (e.g. top PCs calculated on the set of top HVGs) and columns of spatial features (e.g. x and y coordinates). In this case, a tuning parameter to scale the relative value ranges of the columns controls the relative weight between the two data modalities. If the tuning parameter is chosen poorly, either the molecular or spatial features may dominate the clustering. An example of this strategy was used in Maynard et al. (2021).\n\n\n10.4.3 Spatially-aware clustering algorithms\nAlternatively, we can use a spatially-aware clustering algorithm, which directly uses the spatial coordinates of the measurements within the clustering algorithm. Various algorithms have been developed, which have different advantages and make different assumptions, for example identifying spatially compact or spatially connected clusters.\nExamples of spatially-aware clustering algorithms include:\n\nBayesSpace: available as an R package from Bioconductor and described by Zhao et al. (2021)\nBANKSY: available as an R package from Bioconductor version 3.9 onwards and described by Singhal et al. (2024)\nSpaGCN: available as a Python package from GitHub and described by Hu et al. (2021)\nPRECAST: available as an R package from CRAN and described by Liu et al. (2023)\n\n\n\n\n\nHu, Jian, Xiangjie Li, Kyle Coleman, Amelia Schroeder, Nan Ma, David J. Irwin, Edward B. Lee, Russell T. Shinohara, and Mingyao Li. 2021. “SpaGCN: Integrating Gene Expression, Spatial Location and Histology to Identify Spatial Domains and Spatially Variable Genes by Graph Convolutional Network.” Nature Methods 18: 1342–51. https://doi.org/10.1038/s41592-021-01255-8.\n\n\nLiu, Wei, Xu Liao, Ziye Luo, Yi Yang, Mai Chan Lau, Yuling Jiao, Xingjie Shi, et al. 2023. “Probabilistic Embedding, Clustering, and Alignment for Integrating Spatial Transcriptomics Data with PRECAST.” Nature Communications 14: 296. https://doi.org/10.1038/s41467-023-35947-w.\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. “A Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.” F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2.\n\n\nMaynard, Kristen R., Leonardo Collado-Torres, Lukas M. Weber, Cedric Uytingco, Brianna K. Barry, Stephen R. Williams, Joseph L. Catallini II, et al. 2021. “Transcriptome-Scale Spatial Gene Expression in the Human Dorsolateral Prefrontal Cortex.” Nature Neuroscience 24: 425–36. https://doi.org/10.1038/s41593-020-00787-0.\n\n\nSinghal, Vipul, Nigel Chou, Joseph Lee, Yifei Yue, Jinyue Liu, Wan Kee Chock, Li Lin, et al. 2024. “BANKSY Unifies Cell Typing and Tissue Domain Segmentation for Scalable Spatial Omics Data Analysis.” Nature Genetics. https://doi.org/10.1038/s41588-024-01664-3.\n\n\nWeber, Lukas M., Arkajyoti Saha, Abhirup Datta, Kasper D. Hansen, and Stephanie C. Hicks. 2023. “nnSVG for the Scalable Identification of Spatially Variable Genes Using Nearest-Neighbor Gaussian Processes.” Nature Communications 14: 4059. https://doi.org/10.1038/s41467-023-39748-z.\n\n\nZhao, Edward, Matthew R. Stone, Xing Ren, Jamie Guenthoer, Kimberly S. Smythe, Thomas Pulliam, Stephen R. Williams, et al. 2021. “Spatial Transcriptomics at Subspot Resolution with BayesSpace.” Nature Biotechnology 39: 1375–84. https://doi.org/10.1038/s41587-021-00935-2."
  },
  {
    "objectID": "chapters/spot-deconvolution.html#overview",
    "href": "chapters/spot-deconvolution.html#overview",
    "title": "11  Spot deconvolution",
    "section": "11.1 Overview",
    "text": "11.1 Overview\nSpot-level ST data (e.g. from the 10x Genomics Visium platform) can contain zero, one, or multiple cells per spot, depending on the spatial resolution of the platform and the tissue cell density. This characteristic of the data affects several steps in analysis workflows, including quality control (Chapter 6) and clustering (Chapter 10).\nNote that this is also a characteristic of ST data that is distinct from single-cell RNA sequencing data, so here we cannot easily apply existing methods from single-cell workflows.\nIn this section, we will demonstrate methods to deconvolve cell types per spot."
  },
  {
    "objectID": "chapters/spot-deconvolution.html#previous-steps",
    "href": "chapters/spot-deconvolution.html#previous-steps",
    "title": "11  Spot deconvolution",
    "section": "11.2 Previous steps",
    "text": "11.2 Previous steps\nCode to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter.\n\n# LOAD DATA\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\nspe &lt;- Visium_humanDLPFC()"
  },
  {
    "objectID": "chapters/spot-deconvolution.html#number-of-cells-per-spot",
    "href": "chapters/spot-deconvolution.html#number-of-cells-per-spot",
    "title": "11  Spot deconvolution",
    "section": "11.3 Number of cells per spot",
    "text": "11.3 Number of cells per spot\nThe following figure provides an overview of the number of cells per spot in this dataset, which is known in this dataset and stored in a column in colData in the SpatialExperiment object. We use a visualization function from ggspavis to generate the plot.\nWe see that spots in this dataset contain around 0-10 cells, with a mode of 3. Therefore, it is plausible that some spots contain multiple cell types, and spot-level deconvolution could improve downstream analyses by deconvolving these cell types.\n\nlibrary(ggspavis)\n\n# plot number of cells per spot\nplotSpotQC(spe, plot_type = \"histogram\", x_metric = \"cell_count\") + \n  xlab(\"number of cells\") + \n  ggtitle(\"Number of cells per spot\")\n\nWarning: Removed 1353 rows containing non-finite outside the scale range\n(`stat_bin()`)."
  },
  {
    "objectID": "chapters/spatial-registration.html#overview",
    "href": "chapters/spatial-registration.html#overview",
    "title": "12  Spatial registration",
    "section": "12.1 Overview",
    "text": "12.1 Overview\nSpatial registration methods use gene expression profiles for cell populations of interest from single-cell RNA sequencing data as a reference, and use these single-cell expression profiles to ‘spatially register’ the spatial coordinates of observations corresponding to these cell populations in spatial transcriptomics data.\nFor spot-based ST data, this is the same as spot deconvolution using reference-based methods (Chapter 11).\nFor molecule-based ST data, this may be used as an alternative to clustering to identify cell populations after aggregation to cellular resolution (Chapter 10)."
  },
  {
    "objectID": "chapters/differential-expression.html#overview",
    "href": "chapters/differential-expression.html#overview",
    "title": "13  Differential expression",
    "section": "13.1 Overview",
    "text": "13.1 Overview\nIn this chapter, we perform differential expression testing between clusters or spatial domains to identify representative marker genes for each cluster or spatial domain."
  },
  {
    "objectID": "chapters/differential-expression.html#previous-steps",
    "href": "chapters/differential-expression.html#previous-steps",
    "title": "13  Differential expression",
    "section": "13.2 Previous steps",
    "text": "13.2 Previous steps\nCode to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter.\n\n# LOAD DATA\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\nspe &lt;- Visium_humanDLPFC()\n\n# QUALITY CONTROL (QC)\n\nlibrary(scater)\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\n# calculate per-spot QC metrics\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\n# select QC thresholds\nqc_lib_size &lt;- colData(spe)$sum &lt; 600\nqc_detected &lt;- colData(spe)$detected &lt; 400\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 28\nqc_cell_count &lt;- colData(spe)$cell_count &gt; 10\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count\ncolData(spe)$discard &lt;- discard\n# filter low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]\n\n# NORMALIZATION\n\nlibrary(scran)\n# calculate logcounts using library size factors\nspe &lt;- logNormCounts(spe)\n\n# FEATURE SELECTION\n\n# remove mitochondrial genes\nspe &lt;- spe[!is_mito, ]\n# fit mean-variance relationship\ndec &lt;- modelGeneVar(spe)\n# select top HVGs\ntop_hvgs &lt;- getTopHVGs(dec, prop = 0.1)\n\n# DIMENSIONALITY REDUCTION\n\n# compute PCA\nset.seed(123)\nspe &lt;- runPCA(spe, subset_row = top_hvgs)\n# compute UMAP on top 50 PCs\nset.seed(123)\nspe &lt;- runUMAP(spe, dimred = \"PCA\")\n# update column names\ncolnames(reducedDim(spe, \"UMAP\")) &lt;- paste0(\"UMAP\", 1:2)\n\n# CLUSTERING\n\n# graph-based clustering\nset.seed(123)\nk &lt;- 10\ng &lt;- buildSNNGraph(spe, k = k, use.dimred = \"PCA\")\ng_walk &lt;- igraph::cluster_walktrap(g)\nclus &lt;- g_walk$membership\ncolLabels(spe) &lt;- factor(clus)"
  },
  {
    "objectID": "chapters/differential-expression.html#differential-expression-testing",
    "href": "chapters/differential-expression.html#differential-expression-testing",
    "title": "13  Differential expression",
    "section": "13.3 Differential expression testing",
    "text": "13.3 Differential expression testing\nIdentify representative marker genes for each cluster or spatial domain by testing for differential gene expression between clusters.\nHere, we use the findMarkers implementation in scran (Lun, McCarthy, and Marioni 2016), using a binomial test, which tests for genes that differ in the proportion expressed vs. not expressed between clusters. This is a more stringent test than the default t-tests, and tends to select genes that are easier to interpret and validate experimentally.\n\nlibrary(scran)\nlibrary(scater)\nlibrary(pheatmap)\n\n\n# set gene names as row names for easier plotting\nrownames(spe) &lt;- rowData(spe)$gene_name\n\n# test for marker genes\nmarkers &lt;- findMarkers(spe, test = \"binom\", direction = \"up\")\n\n# returns a list with one DataFrame per cluster\nmarkers\n\nList of length 7\nnames(7): 1 2 3 4 5 6 7\n\n\n\n# plot log-fold changes for one cluster over all other clusters\n# selecting cluster 1\ninteresting &lt;- markers[[1]]\nbest_set &lt;- interesting[interesting$Top &lt;= 5, ]\nlogFCs &lt;- getMarkerEffects(best_set)\n\npheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))\n\n\n\n\n\n# plot log-transformed normalized expression of top genes for one cluster\ntop_genes &lt;- head(rownames(interesting))\n\nplotExpression(spe, x = \"label\", features = top_genes)"
  },
  {
    "objectID": "chapters/differential-expression.html#pseudobulking",
    "href": "chapters/differential-expression.html#pseudobulking",
    "title": "13  Differential expression",
    "section": "13.4 Pseudobulking",
    "text": "13.4 Pseudobulking\nAlternatively, we can proceed by manually aggregating the counts per cluster or spatial domain, which is referred to as ‘pseudobulking’. Then, we can perform differential expression testing between the pseudobulked clusters or spatial domains.\n\n\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. “A Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.” F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2."
  },
  {
    "objectID": "chapters/multiple-samples.html#overview",
    "href": "chapters/multiple-samples.html#overview",
    "title": "14  Multiple samples",
    "section": "14.1 Overview",
    "text": "14.1 Overview\nIn the preceding chapters, we have focused on spatial transcriptomics datasets consisting of a single tissue section, which we refer to as a sample.\nDatasets consisting of multiple samples from one or more biological conditions are used to study a variety of biological questions, such as characterizing biological variability within replicate tissue samples, or differential comparisons between biological conditions.\nThese datasets require additional analysis methods that can make full use of the information contained in multiple samples in a computationally efficient and statistically rigorous manner."
  },
  {
    "objectID": "chapters/spatial-co-localization.html#overview",
    "href": "chapters/spatial-co-localization.html#overview",
    "title": "15  Spatial co-localization",
    "section": "15.1 Overview",
    "text": "15.1 Overview\nIn this chapter, we will show examples of analyses to investigate spatial co-localization of cell types.\nFor these analyses, we will use a different dataset that provides single-cell spatial resolution, e.g. from the 10x Genomics Xenium platform."
  },
  {
    "objectID": "chapters/spatial-co-localization.html#previous-steps",
    "href": "chapters/spatial-co-localization.html#previous-steps",
    "title": "15  Spatial co-localization",
    "section": "15.2 Previous steps",
    "text": "15.2 Previous steps\nCode to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter."
  },
  {
    "objectID": "chapters/spatial-co-localization.html#spatial-co-localization-of-cell-types-within-a-single-sample",
    "href": "chapters/spatial-co-localization.html#spatial-co-localization-of-cell-types-within-a-single-sample",
    "title": "15  Spatial co-localization",
    "section": "15.3 Spatial co-localization of cell types within a single sample",
    "text": "15.3 Spatial co-localization of cell types within a single sample\nWe will use the spicyR Bioconductor package (Canete et al. 2022) for the following examples.\n\n\n\n\n\nCanete, Nicolas P., Sourish S. Iyengar, John T. Ormerod, Heeva Baharlou, Andrew N. Harman, and Ellis Patrick. 2022. “spicyR: Spatial Analysis of in Situ Cytometry Data in R.” Bioinformatics 38: 3099–3105. https://doi.org/10.1093/bioinformatics/btac268."
  },
  {
    "objectID": "chapters/workflows.html",
    "href": "chapters/workflows.html",
    "title": "16  Workflows",
    "section": "",
    "text": "This part contains several extended chapters containing examples of complete analysis workflows.\nEach chapter uses a specific example dataset and a selected set of analysis methods. The workflows have been selected to showcase certain types of analyses or datasets from specific technological platforms. Each workflow includes some discussion on the analyses and methods used, and interactive R code examples.\nFor more details on the individual analysis steps, see the chapters in the previous part (Chapter 4)."
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#overview",
    "href": "chapters/workflow-Visium-humanDLPFC.html#overview",
    "title": "17  Human DLPFC workflow",
    "section": "17.1 Overview",
    "text": "17.1 Overview\nThis workflow analyzes one sample of human brain from the dorsolateral prefrontal cortex (DLPFC) region, measured using the 10x Genomics Visium platform. This is a condensed version of the analyses shown in the individual analysis chapters in the previous part. For more details on the individual steps, see the previous chapters."
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#description-of-dataset",
    "href": "chapters/workflow-Visium-humanDLPFC.html#description-of-dataset",
    "title": "17  Human DLPFC workflow",
    "section": "17.2 Description of dataset",
    "text": "17.2 Description of dataset\nThis is a 10x Genomics Visium dataset generated from healthy human brain samples from the dorsolateral prefrontal cortex (DLPFC) region.\nIn the full dataset, there are 12 samples in total, from 3 individuals, with 2 pairs of spatially adjacent replicates (serial sections) per individual (4 samples per individual). The individuals and spatially adjacent replicates can be used as blocking factors. Each sample spans the six layers of the cortex plus white matter in a perpendicular tissue section.\nFor the examples in this workflow and the analysis chapters, we use a single sample from this dataset (sample 151673), to keep the computational requirements to compile the book manageable.\nFor more details on the dataset, see Maynard et al. (2021). The full dataset is publicly available through the spatialLIBD Bioconductor package. The dataset can also be explored interactively through the spatialLIBD Shiny web app."
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#load-data",
    "href": "chapters/workflow-Visium-humanDLPFC.html#load-data",
    "title": "17  Human DLPFC workflow",
    "section": "17.3 Load data",
    "text": "17.3 Load data\nHere, we load a single sample from this dataset (sample 151673), which is available as a SpatialExperiment object from the STexampleData package.\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\n\n# load object\nspe &lt;- Visium_humanDLPFC()\nspe\n\nclass: SpatialExperiment \ndim: 33538 4992 \nmetadata(0):\nassays(1): counts\nrownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475\n  ENSG00000268674\nrowData names(3): gene_id gene_name feature_type\ncolnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ...\n  TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1\ncolData names(7): barcode_id sample_id ... ground_truth cell_count\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(4): sample_id image_id data scaleFactor"
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#plot-data",
    "href": "chapters/workflow-Visium-humanDLPFC.html#plot-data",
    "title": "17  Human DLPFC workflow",
    "section": "17.4 Plot data",
    "text": "17.4 Plot data\nAs an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide, to check that the object has loaded correctly and that the orientation is as expected.\nWe use visualization functions from the ggspavis package to generate plots.\n\nlibrary(ggspavis)\n\n\n# plot spatial coordinates (spots)\nplotSpots(spe)"
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#quality-control-qc",
    "href": "chapters/workflow-Visium-humanDLPFC.html#quality-control-qc",
    "title": "17  Human DLPFC workflow",
    "section": "17.5 Quality control (QC)",
    "text": "17.5 Quality control (QC)\nFirst, we subset the object to keep only spots over tissue. The remaining spots are background spots, which we exclude.\n\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\ndim(spe)\n\n[1] 33538  3639\n\n\nNext, calculate spot-level QC metrics using the scater package (McCarthy et al. 2017), and store the QC metrics in colData. See Chapter 6 for more details, including explanations of the QC metrics.\n\nlibrary(scater)\n\n\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\ntable(is_mito)\n\nis_mito\nFALSE  TRUE \n33525    13 \n\nrowData(spe)$gene_name[is_mito]\n\n [1] \"MT-ND1\"  \"MT-ND2\"  \"MT-CO1\"  \"MT-CO2\"  \"MT-ATP8\" \"MT-ATP6\" \"MT-CO3\" \n [8] \"MT-ND3\"  \"MT-ND4L\" \"MT-ND4\"  \"MT-ND5\"  \"MT-ND6\"  \"MT-CYB\" \n\n# calculate per-spot QC metrics and store in colData\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\nhead(colData(spe), 3)\n\nDataFrame with 3 rows and 13 columns\n                           barcode_id     sample_id in_tissue array_row\n                          &lt;character&gt;   &lt;character&gt; &lt;integer&gt; &lt;integer&gt;\nAAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 sample_151673         1        50\nAAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 sample_151673         1         3\nAAACACCAATAACTGC-1 AAACACCAATAACTGC-1 sample_151673         1        59\n                   array_col ground_truth cell_count       sum  detected\n                   &lt;integer&gt;  &lt;character&gt;  &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt;\nAAACAAGTATCTCCCA-1       102       Layer3          6      8458      3586\nAAACAATCTACTAGCA-1        43       Layer1         16      1667      1150\nAAACACCAATAACTGC-1        19           WM          5      3769      1960\n                   subsets_mito_sum subsets_mito_detected subsets_mito_percent\n                          &lt;numeric&gt;             &lt;numeric&gt;            &lt;numeric&gt;\nAAACAAGTATCTCCCA-1             1407                    13              16.6351\nAAACAATCTACTAGCA-1              204                    11              12.2376\nAAACACCAATAACTGC-1              430                    13              11.4089\n                       total\n                   &lt;numeric&gt;\nAAACAAGTATCTCCCA-1      8458\nAAACAATCTACTAGCA-1      1667\nAAACACCAATAACTGC-1      3769\n\n\nSelect filtering thresholds for the QC metrics by examining distributions using histograms. For additional details, including further exploratory visualizations to select the thresholds, see Chapter 6. Here, we use relatively relaxed thresholds, since the additional exploratory visualizations showed that more stringent thresholds tended to remove groups of spots corresponding to biologically meaningful regions.\n\n# histograms of QC metrics\npar(mfrow = c(1, 4))\nhist(colData(spe)$sum, xlab = \"sum\", main = \"UMIs per spot\")\nhist(colData(spe)$detected, xlab = \"detected\", main = \"Genes per spot\")\nhist(colData(spe)$subsets_mito_percent, xlab = \"percent mitochondrial\", main = \"Percent mito UMIs\")\nhist(colData(spe)$cell_count, xlab = \"number of cells\", main = \"No. cells per spot\")\n\n\n\npar(mfrow = c(1, 1))\n\n# select QC thresholds\nqc_lib_size &lt;- colData(spe)$sum &lt; 600\nqc_detected &lt;- colData(spe)$detected &lt; 400\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 28\nqc_cell_count &lt;- colData(spe)$cell_count &gt; 10\n\n# number of discarded spots for each metric\napply(cbind(qc_lib_size, qc_detected, qc_mito, qc_cell_count), 2, sum)\n\n  qc_lib_size   qc_detected       qc_mito qc_cell_count \n            8             7            17            90 \n\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count\ntable(discard)\n\ndiscard\nFALSE  TRUE \n 3524   115 \n\n# store in object\ncolData(spe)$discard &lt;- discard\n\nPlot the set of discarded spots in the spatial x-y coordinates, to confirm that the spatial distribution of the discarded spots does not correspond to any biologically meaningful regions, which would indicate that we are removing biologically informative spots.\n\n# check spatial pattern of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", annotate = \"discard\")\n\n\n\n\nThere is some concentration of discarded spots at the edge of the tissue region, which may be due to tissue damage. Importantly, the discarded spots do not correspond to any of the cortical layers of interest.\nWe filter out the low-quality spots from the object.\n\n# filter low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]\ndim(spe)\n\n[1] 33538  3524"
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#normalization",
    "href": "chapters/workflow-Visium-humanDLPFC.html#normalization",
    "title": "17  Human DLPFC workflow",
    "section": "17.6 Normalization",
    "text": "17.6 Normalization\nCalculate log-transformed normalized counts (logcounts) with the library size factors methodology, using methods from scater (McCarthy et al. 2017) and scran (Lun, McCarthy, and Marioni 2016), making the assumption that spots can be treated as equivalent to cells. For more details, see Chapter 7.\n\nlibrary(scran)\n\n\n# calculate library size factors\nspe &lt;- computeLibraryFactors(spe)\n\nsummary(sizeFactors(spe))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.1321  0.6312  0.9000  1.0000  1.2849  3.7582 \n\nhist(sizeFactors(spe), breaks = 20)\n\n\n\n# calculate logcounts and store in object\nspe &lt;- logNormCounts(spe)\n\nassayNames(spe)\n\n[1] \"counts\"    \"logcounts\""
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#feature-selection",
    "href": "chapters/workflow-Visium-humanDLPFC.html#feature-selection",
    "title": "17  Human DLPFC workflow",
    "section": "17.7 Feature selection",
    "text": "17.7 Feature selection\nIdentify a set of top highly variable genes (HVGs), which will be used to define cell types. We use methods from scran (Lun, McCarthy, and Marioni 2016), treating spots as equivalent to single cells, and considering only molecular features (gene expression) as described in Chapter 8. We also first filter out mitochondrial genes, since these are very highly expressed and not of main biological interest here.\n\n# remove mitochondrial genes\nspe &lt;- spe[!is_mito, ]\ndim(spe)\n\n[1] 33525  3524\n\n\n\n# fit mean-variance relationship\ndec &lt;- modelGeneVar(spe)\n\n# visualize mean-variance relationship\nfit &lt;- metadata(dec)\nplot(fit$mean, fit$var, \n     xlab = \"mean of log-expression\", ylab = \"variance of log-expression\")\ncurve(fit$trend(x), col = \"dodgerblue\", add = TRUE, lwd = 2)\n\n\n\n# select top HVGs\ntop_hvgs &lt;- getTopHVGs(dec, prop = 0.1)\nlength(top_hvgs)\n\n[1] 1438"
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#spatially-aware-feature-selection",
    "href": "chapters/workflow-Visium-humanDLPFC.html#spatially-aware-feature-selection",
    "title": "17  Human DLPFC workflow",
    "section": "17.8 Spatially-aware feature selection",
    "text": "17.8 Spatially-aware feature selection\nAlternatively, run nnSVG (Weber et al. 2023) to identify a set of top spatially variable genes (SVGs) instead of HVGs.\nHere, we run nnSVG using a small subset of the dataset for faster runtime. We select a subset of the data by subsampling on the set of spots and including stringent filtering for low-expressed genes. For a full analysis, we recommend running nnSVG on all spots and using default filtering parameters (for Visium data from human brain tissue), which takes around 45 minutes for one Visium slide on a standard laptop using multiple cores.\n\nlibrary(nnSVG)\n\n\n# subsample spots\nn &lt;- 100\nset.seed(123)\nix &lt;- sample(seq_len(n), n)\n\nspe_nnSVG &lt;- spe[, ix]\n\n# filter low-expressed and mitochondrial genes\n# using very stringent filtering parameters for faster runtime in this example\n# note: for a full analysis, use alternative filtering parameters (e.g. defaults)\nspe_nnSVG &lt;- filter_genes(\n  spe_nnSVG, filter_genes_ncounts = 10, filter_genes_pcspots = 3\n)\n\nGene filtering: removing mitochondrial genes\n\n\nremoved 0 mitochondrial genes\n\n\nGene filtering: retaining genes with at least 10 counts in at least 3% (n = 3) of spatial locations\n\n\nremoved 33353 out of 33525 genes due to low expression\n\n# re-calculate logcounts after filtering\n# using library size factors\nspe_nnSVG &lt;- logNormCounts(spe_nnSVG)\n\n# run nnSVG\n# using a single core for compatibility on build system\n# note: for a full analysis, use multiple cores\nset.seed(123)\nspe_nnSVG &lt;- nnSVG(spe_nnSVG, n_threads = 1)\n\n# investigate results\n\n# show results\nhead(rowData(spe_nnSVG), 3)\n\nDataFrame with 3 rows and 17 columns\n                        gene_id   gene_name    feature_type   sigma.sq\n                    &lt;character&gt; &lt;character&gt;     &lt;character&gt;  &lt;numeric&gt;\nENSG00000074800 ENSG00000074800        ENO1 Gene Expression 0.00840777\nENSG00000171603 ENSG00000171603      CLSTN1 Gene Expression 0.43102027\nENSG00000162545 ENSG00000162545     CAMK2N1 Gene Expression 0.15373440\n                   tau.sq       phi    loglik   runtime      mean       var\n                &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSG00000074800  0.518011  15.82454  -109.808     0.018   1.75820  0.530929\nENSG00000171603  0.298698  18.12310  -123.212     0.023   2.07433  0.741077\nENSG00000162545  0.547736   2.38046  -119.576     0.016   2.63576  0.702846\n                    spcov   prop_sv loglik_lm   LR_stat      rank      pval\n                &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSG00000074800 0.0521523 0.0159716  -109.735 -0.145454       167 1.0000000\nENSG00000171603 0.3164987 0.5906665  -126.409  6.394009        86 0.0408845\nENSG00000162545 0.1487576 0.2191603  -123.760  8.368951        70 0.0152302\n                     padj\n                &lt;numeric&gt;\nENSG00000074800 1.0000000\nENSG00000171603 0.0817690\nENSG00000162545 0.0374227\n\n# number of significant SVGs\ntable(rowData(spe_nnSVG)$padj &lt;= 0.05)\n\n\nFALSE  TRUE \n   96    76 \n\n# show results for top n SVGs\nrowData(spe_nnSVG)[order(rowData(spe_nnSVG)$rank)[1:6], ]\n\nDataFrame with 6 rows and 17 columns\n                        gene_id   gene_name    feature_type  sigma.sq    tau.sq\n                    &lt;character&gt; &lt;character&gt;     &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSG00000197971 ENSG00000197971         MBP Gene Expression   3.92430  0.175336\nENSG00000123560 ENSG00000123560        PLP1 Gene Expression   3.23544  0.461590\nENSG00000109846 ENSG00000109846       CRYAB Gene Expression   1.89968  0.281795\nENSG00000173786 ENSG00000173786         CNP Gene Expression   2.28793  0.402524\nENSG00000131095 ENSG00000131095        GFAP Gene Expression   2.23709  0.461297\nENSG00000160307 ENSG00000160307       S100B Gene Expression   1.24179  0.155737\n                      phi    loglik   runtime      mean       var     spcov\n                &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSG00000197971   0.93014  -118.372     0.023   3.78073   2.76535  0.523969\nENSG00000123560   1.03983  -140.269     0.018   2.86143   3.02555  0.628613\nENSG00000109846   1.88555  -126.692     0.018   1.86058   1.88123  0.740785\nENSG00000173786   1.02675  -129.206     0.018   1.79558   1.97274  0.842396\nENSG00000131095   2.49083  -149.004     0.019   1.94543   2.71281  0.768823\nENSG00000160307   5.76279  -129.722     0.015   1.82695   1.46946  0.609953\n                  prop_sv loglik_lm   LR_stat      rank        pval        padj\n                &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;   &lt;numeric&gt;   &lt;numeric&gt;\nENSG00000197971  0.957231  -192.250  147.7556         1 0.00000e+00 0.00000e+00\nENSG00000123560  0.875146  -196.746  112.9549         2 0.00000e+00 0.00000e+00\nENSG00000109846  0.870824  -172.988   92.5906         3 0.00000e+00 0.00000e+00\nENSG00000173786  0.850388  -175.363   92.3137         4 0.00000e+00 0.00000e+00\nENSG00000131095  0.829047  -191.291   84.5739         5 0.00000e+00 0.00000e+00\nENSG00000160307  0.888562  -160.636   61.8281         6 3.75255e-14 1.07573e-12\n\n# identify top-ranked SVG\nrowData(spe_nnSVG)$gene_name[which(rowData(spe_nnSVG)$rank == 1)]\n\n[1] \"MBP\""
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#dimensionality-reduction",
    "href": "chapters/workflow-Visium-humanDLPFC.html#dimensionality-reduction",
    "title": "17  Human DLPFC workflow",
    "section": "17.9 Dimensionality reduction",
    "text": "17.9 Dimensionality reduction\nRun principal component analysis (PCA) on the set of top HVGs, and retain the top 50 principal components (PCs) for further downstream analyses. This is done both to reduce noise and to improve computational efficiency. We also run UMAP on the set of top 50 PCs and retain the top 2 UMAP components for visualization purposes.\nWe use the computationally efficient implementation of PCA available in scater (McCarthy et al. 2017), which uses randomization, and therefore requires setting a random seed for reproducibility.\n\n# compute PCA\nset.seed(123)\nspe &lt;- runPCA(spe, subset_row = top_hvgs)\n\nreducedDimNames(spe)\n\n[1] \"PCA\"\n\ndim(reducedDim(spe, \"PCA\"))\n\n[1] 3524   50\n\n\n\n# compute UMAP on top 50 PCs\nset.seed(123)\nspe &lt;- runUMAP(spe, dimred = \"PCA\")\n\nreducedDimNames(spe)\n\n[1] \"PCA\"  \"UMAP\"\n\ndim(reducedDim(spe, \"UMAP\"))\n\n[1] 3524    2\n\n# update column names for easier plotting\ncolnames(reducedDim(spe, \"UMAP\")) &lt;- paste0(\"UMAP\", 1:2)"
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#clustering",
    "href": "chapters/workflow-Visium-humanDLPFC.html#clustering",
    "title": "17  Human DLPFC workflow",
    "section": "17.10 Clustering",
    "text": "17.10 Clustering\nNext, we perform clustering to define cell types. Here, we use molecular features (gene expression) only, as described in Chapter 10. We apply graph-based clustering using the Walktrap method implemented in scran (Lun, McCarthy, and Marioni 2016), applied to the top 50 PCs calculated on the set of top HVGs.\n\n# graph-based clustering\nset.seed(123)\nk &lt;- 10\ng &lt;- buildSNNGraph(spe, k = k, use.dimred = \"PCA\")\ng_walk &lt;- igraph::cluster_walktrap(g)\nclus &lt;- g_walk$membership\ntable(clus)\n\nclus\n   1    2    3    4    5    6    7 \n 338  312 1146  978  274  116  360 \n\n# store cluster labels in column 'label' in colData\ncolLabels(spe) &lt;- factor(clus)\n\nVisualize the clusters by plotting in spatial (x-y) coordinates on the tissue slide, and in UMAP dimensions.\nFrom the visualizations, we can see that the clustering reproduces the known biological structure (cortical layers), although not perfectly. The clusters are also separated in UMAP space, but again not perfectly.\n\n# plot clusters in spatial x-y coordinates\nplotSpots(spe, annotate = \"label\", \n          pal = \"libd_layer_colors\")\n\n\n\n# plot ground truth labels in spatial coordinates\nplotSpots(spe, annotate = \"ground_truth\", \n          pal = \"libd_layer_colors\")\n\n\n\n\n\n# plot clusters in UMAP reduced dimensions\nplotDimRed(spe, plot_type = \"UMAP\", \n           annotate = \"label\", pal = \"libd_layer_colors\")"
  },
  {
    "objectID": "chapters/workflow-Visium-humanDLPFC.html#differential-expression",
    "href": "chapters/workflow-Visium-humanDLPFC.html#differential-expression",
    "title": "17  Human DLPFC workflow",
    "section": "17.11 Differential expression",
    "text": "17.11 Differential expression\nIdentify marker genes by testing for differential gene expression between clusters. We use the findMarkers implementation in scran (Lun, McCarthy, and Marioni 2016), using a binomial test, which tests for genes that differ in the proportion expressed vs. not expressed between clusters. This is a more stringent test than the default t-tests, and tends to select genes that are easier to interpret and validate experimentally.\n\n# set gene names as row names for easier plotting\nrownames(spe) &lt;- rowData(spe)$gene_name\n\n# test for marker genes\nmarkers &lt;- findMarkers(spe, test = \"binom\", direction = \"up\")\n\n# returns a list with one DataFrame per cluster\nmarkers\n\nList of length 7\nnames(7): 1 2 3 4 5 6 7\n\n\n\nlibrary(pheatmap)\n\n\n# plot log-fold changes for one cluster over all other clusters\n# selecting cluster 1\ninteresting &lt;- markers[[1]]\nbest_set &lt;- interesting[interesting$Top &lt;= 5, ]\nlogFCs &lt;- getMarkerEffects(best_set)\n\npheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))\n\n\n\n\n\n# plot log-transformed normalized expression of top genes for one cluster\ntop_genes &lt;- head(rownames(interesting))\n\nplotExpression(spe, x = \"label\", features = top_genes)\n\n\n\n\n\n\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. “A Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.” F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2.\n\n\nMaynard, Kristen R., Leonardo Collado-Torres, Lukas M. Weber, Cedric Uytingco, Brianna K. Barry, Stephen R. Williams, Joseph L. Catallini II, et al. 2021. “Transcriptome-Scale Spatial Gene Expression in the Human Dorsolateral Prefrontal Cortex.” Nature Neuroscience 24: 425–36. https://doi.org/10.1038/s41593-020-00787-0.\n\n\nMcCarthy, Davis J., Kieran R. Campbell, Aaron T. L. Lun, and Quin F. Wills. 2017. “Scater: Pre-Processing, Quality Control, Normalization and Visualization of Single-Cell RNA-seq Data in R.” Bioinformatics 33 (8): 1179–86. https://doi.org/10.1093/bioinformatics/btw777.\n\n\nWeber, Lukas M., Arkajyoti Saha, Abhirup Datta, Kasper D. Hansen, and Stephanie C. Hicks. 2023. “nnSVG for the Scalable Identification of Spatially Variable Genes Using Nearest-Neighbor Gaussian Processes.” Nature Communications 14: 4059. https://doi.org/10.1038/s41467-023-39748-z."
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#overview",
    "href": "chapters/workflow-Visium-mouseCoronal.html#overview",
    "title": "18  Mouse coronal workflow",
    "section": "18.1 Overview",
    "text": "18.1 Overview\nThis workflow analyzes a mouse coronal brain section dataset from the 10x Genomics Visium platform. This dataset was generated by 10x Genomics, and the raw data files are publicly available from the 10x Genomics website."
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#description-of-dataset",
    "href": "chapters/workflow-Visium-mouseCoronal.html#description-of-dataset",
    "title": "18  Mouse coronal workflow",
    "section": "18.2 Description of dataset",
    "text": "18.2 Description of dataset\nThis dataset measures transcriptome-wide gene expression on a Visium slide spanning one hemisphere of a mouse coronal brain section. For experimental details, see the 10x Genomics website.\nDue to the small size of the mouse brain and the dimensions of the Visium slide (6.5mm x 6.5mm), the measurements span an entire brain hemisphere. Therefore, we can use this dataset to compare gene expression profiles between major anatomical regions of the mouse brain. Due to the small size of cells in the mouse brain, each spot can contain up to 50 cells. In this dataset, we do not know the exact number of cells per spot."
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#load-data",
    "href": "chapters/workflow-Visium-mouseCoronal.html#load-data",
    "title": "18  Mouse coronal workflow",
    "section": "18.3 Load data",
    "text": "18.3 Load data\nThe dataset is available in SpatialExperiment format from the STexampleData package.\n\nlibrary(SpatialExperiment)\nlibrary(STexampleData)\n\n# load object\nspe &lt;- Visium_mouseCoronal()\nspe\n\nclass: SpatialExperiment \ndim: 32285 4992 \nmetadata(0):\nassays(1): counts\nrownames(32285): ENSMUSG00000051951 ENSMUSG00000089699 ...\n  ENSMUSG00000095019 ENSMUSG00000095041\nrowData names(3): gene_id gene_name feature_type\ncolnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ...\n  TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1\ncolData names(5): barcode_id sample_id in_tissue array_row array_col\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(4): sample_id image_id data scaleFactor"
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#plot-data",
    "href": "chapters/workflow-Visium-mouseCoronal.html#plot-data",
    "title": "18  Mouse coronal workflow",
    "section": "18.4 Plot data",
    "text": "18.4 Plot data\nAs an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide. This confirms that the object has loaded correctly, and the orientation matches the 10x Genomics website.\nWe use visualization functions from the ggspavis package to generate plots.\n\nlibrary(ggspavis)\n\n\n# plot spatial coordinates (spots)\nplotSpots(spe)"
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#quality-control-qc",
    "href": "chapters/workflow-Visium-mouseCoronal.html#quality-control-qc",
    "title": "18  Mouse coronal workflow",
    "section": "18.5 Quality control (QC)",
    "text": "18.5 Quality control (QC)\nSubset object to keep only spots over tissue.\n\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\ndim(spe)\n\n[1] 32285  2702\n\n\nCalculate spot-level QC metrics using the scater package (McCarthy et al. 2017), and store the QC metrics in colData.\n\nlibrary(scater)\n\n\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\ntable(is_mito)\n\nis_mito\nFALSE  TRUE \n32272    13 \n\nrowData(spe)$gene_name[is_mito]\n\n [1] \"mt-Nd1\"  \"mt-Nd2\"  \"mt-Co1\"  \"mt-Co2\"  \"mt-Atp8\" \"mt-Atp6\" \"mt-Co3\" \n [8] \"mt-Nd3\"  \"mt-Nd4l\" \"mt-Nd4\"  \"mt-Nd5\"  \"mt-Nd6\"  \"mt-Cytb\"\n\n# calculate per-spot QC metrics and store in colData\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\nhead(colData(spe), 3)\n\nDataFrame with 3 rows and 11 columns\n                           barcode_id   sample_id in_tissue array_row array_col\n                          &lt;character&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;\nAAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1    sample01         1        50       102\nAAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1    sample01         1         3        43\nAAACACCAATAACTGC-1 AAACACCAATAACTGC-1    sample01         1        59        19\n                         sum  detected subsets_mito_sum subsets_mito_detected\n                   &lt;numeric&gt; &lt;numeric&gt;        &lt;numeric&gt;             &lt;numeric&gt;\nAAACAAGTATCTCCCA-1     20935      5230             4036                    13\nAAACAATCTACTAGCA-1     14789      3646             3419                    13\nAAACACCAATAACTGC-1     34646      6272             5068                    13\n                   subsets_mito_percent     total\n                              &lt;numeric&gt; &lt;numeric&gt;\nAAACAAGTATCTCCCA-1              19.2787     20935\nAAACAATCTACTAGCA-1              23.1185     14789\nAAACACCAATAACTGC-1              14.6280     34646\n\n\nSelect filtering thresholds for the QC metrics by examining distributions using histograms.\n\n# histograms of QC metrics\npar(mfrow = c(1, 3))\nhist(colData(spe)$sum, xlab = \"sum\", main = \"UMIs per spot\")\nhist(colData(spe)$detected, xlab = \"detected\", main = \"Genes per spot\")\nhist(colData(spe)$subsets_mito_percent, xlab = \"percent mitochondrial\", main = \"Percent mito UMIs\")\n\n\n\npar(mfrow = c(1, 1))\n\n# select QC thresholds\nqc_lib_size &lt;- colData(spe)$sum &lt; 5000\nqc_detected &lt;- colData(spe)$detected &lt; 1000\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30\n\n# number of discarded spots for each QC metric\napply(cbind(qc_lib_size, qc_detected, qc_mito), 2, sum)\n\nqc_lib_size qc_detected     qc_mito \n          9           4          11 \n\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito\ntable(discard)\n\ndiscard\nFALSE  TRUE \n 2683    19 \n\n# store in object\ncolData(spe)$discard &lt;- discard\n\nPlot discarded spots in x-y coordinates on the tissue slide to check if there is any biologically meaningful spatial pattern. This would be problematic, since it would mean we are removing biologically informative spots.\n\n# check spatial pattern of discarded spots\nplotSpotQC(spe, plot_type = \"spot\", annotate = \"discard\")\n\n\n\n\nThere is one small region with some concentrated discarded spots at the top-left. However, this does not appear to correspond to any specific known anatomical region of interest. We assume that these are low-quality spots, and filtering them out will not cause problems in the biological interpretation.\nWe filter out the low-quality spots from the object.\n\n# filter low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]\ndim(spe)\n\n[1] 32285  2683"
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#normalization",
    "href": "chapters/workflow-Visium-mouseCoronal.html#normalization",
    "title": "18  Mouse coronal workflow",
    "section": "18.6 Normalization",
    "text": "18.6 Normalization\nNext, we calculate log-transformed normalized counts (logcounts) with the library size factors methodology, using methods from scater (McCarthy et al. 2017) and scran (Lun, McCarthy, and Marioni 2016).\n\nlibrary(scran)\n\n\n# calculate library size factors\nspe &lt;- computeLibraryFactors(spe)\n\nsummary(sizeFactors(spe))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.1615  0.6597  0.9083  1.0000  1.2342  4.8973 \n\nhist(log10(sizeFactors(spe)), xlab = \"log10 (size factors)\", main = \"Size factors\")\n\n\n\n# calculate logcounts and store in object\nspe &lt;- logNormCounts(spe)\n\nassayNames(spe)\n\n[1] \"counts\"    \"logcounts\""
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#feature-selection",
    "href": "chapters/workflow-Visium-mouseCoronal.html#feature-selection",
    "title": "18  Mouse coronal workflow",
    "section": "18.7 Feature selection",
    "text": "18.7 Feature selection\nIdentify a set of top highly variable genes (HVGs), which will be used to define cell types. We use methods from scran (Lun, McCarthy, and Marioni 2016), and first filter out mitochondrial genes (since these are very highly expressed and not of biological interest here).\n\n# remove mitochondrial genes\nspe &lt;- spe[!is_mito, ]\ndim(spe)\n\n[1] 32272  2683\n\n\n\n# fit mean-variance relationship\ndec &lt;- modelGeneVar(spe)\n\n# visualize mean-variance relationship\nfit &lt;- metadata(dec)\nplot(fit$mean, fit$var, \n     xlab = \"mean of log-expression\", ylab = \"variance of log-expression\")\ncurve(fit$trend(x), col = \"dodgerblue\", add = TRUE, lwd = 2)\n\n\n\n# select top HVGs\ntop_hvgs &lt;- getTopHVGs(dec, prop = 0.1)\nlength(top_hvgs)\n\n[1] 1274\n\n\nNote there are a few extremely highly expressed genes, which influence the fitted mean-variance relationship. We check the names of these genes to decide whether they should be removed as outliers.\n\n# identify outlier genes\nrev(sort(fit$mean))[1:3]\n\nENSMUSG00000115783 ENSMUSG00000098178 ENSMUSG00000024661 \n         10.934946           9.847532           7.313407 \n\noutlier_ids &lt;- names(rev(sort(fit$mean))[1:3])\n\nrowData(spe)[outlier_ids, ]\n\nDataFrame with 3 rows and 3 columns\n                              gene_id   gene_name    feature_type\n                          &lt;character&gt; &lt;character&gt;     &lt;character&gt;\nENSMUSG00000115783 ENSMUSG00000115783         Bc1 Gene Expression\nENSMUSG00000098178 ENSMUSG00000098178     Gm42418 Gene Expression\nENSMUSG00000024661 ENSMUSG00000024661        Fth1 Gene Expression\n\n\nThese appear to be biologically meaningful genes, so we leave them in."
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#spatially-aware-feature-selection",
    "href": "chapters/workflow-Visium-mouseCoronal.html#spatially-aware-feature-selection",
    "title": "18  Mouse coronal workflow",
    "section": "18.8 Spatially-aware feature selection",
    "text": "18.8 Spatially-aware feature selection\nAlternatively, run nnSVG (Weber et al. 2023) to identify a set of top spatially variable genes (SVGs) instead of HVGs.\nHere, we run nnSVG using a small subset of the dataset for faster runtime. We select a subset of the data by subsampling on the set of spots and including stringent filtering for low-expressed genes. For a full analysis, we recommend running nnSVG on all spots and using alternative filtering parameters (for Visium data from mouse brain tissue), which takes around 45 minutes for one Visium slide on a standard laptop using multiple cores.\n\nlibrary(nnSVG)\n\n\n# subsample spots\nn &lt;- 100\nset.seed(123)\nix &lt;- sample(seq_len(n), n)\n\nspe_nnSVG &lt;- spe[, ix]\n\n# filter low-expressed and mitochondrial genes\n# using very stringent filtering parameters for faster runtime in this example\n# note: for a full analysis, use alternative filtering parameters (e.g. defaults)\nspe_nnSVG &lt;- filter_genes(\n  spe_nnSVG, filter_genes_ncounts = 50, filter_genes_pcspots = 5\n)\n\nGene filtering: removing mitochondrial genes\n\n\nremoved 0 mitochondrial genes\n\n\nGene filtering: retaining genes with at least 50 counts in at least 5% (n = 5) of spatial locations\n\n\nremoved 32074 out of 32272 genes due to low expression\n\n# re-calculate logcounts after filtering\n# using library size factors\nspe_nnSVG &lt;- logNormCounts(spe_nnSVG)\n\n# run nnSVG\n# using a single core for compatibility on build system\n# note: for a full analysis, use multiple cores\nset.seed(123)\nspe_nnSVG &lt;- nnSVG(spe_nnSVG, n_threads = 1)\n\n# investigate results\n\n# show results\nhead(rowData(spe_nnSVG), 3)\n\nDataFrame with 3 rows and 17 columns\n                              gene_id   gene_name    feature_type  sigma.sq\n                          &lt;character&gt; &lt;character&gt;     &lt;character&gt; &lt;numeric&gt;\nENSMUSG00000061518 ENSMUSG00000061518       Cox5b Gene Expression 0.0210665\nENSMUSG00000073702 ENSMUSG00000073702       Rpl31 Gene Expression 0.0688871\nENSMUSG00000046330 ENSMUSG00000046330      Rpl37a Gene Expression 0.0549986\n                      tau.sq       phi    loglik   runtime      mean       var\n                   &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSMUSG00000061518 0.1202984  13.53194  -43.6472     0.026   4.98425  0.142977\nENSMUSG00000073702 0.0860842   5.84110  -40.3003     0.015   4.83432  0.143616\nENSMUSG00000046330 0.1133114   6.47579  -48.2811     0.018   5.35620  0.166734\n                       spcov   prop_sv loglik_lm   LR_stat      rank      pval\n                   &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSMUSG00000061518 0.0291204  0.149022  -44.1377  0.981135       184 0.6122789\nENSMUSG00000073702 0.0542917  0.444515  -44.3607  8.120691       147 0.0172431\nENSMUSG00000046330 0.0437844  0.326770  -51.8235  7.084636       151 0.0289462\n                        padj\n                   &lt;numeric&gt;\nENSMUSG00000061518 0.6588653\nENSMUSG00000073702 0.0232254\nENSMUSG00000046330 0.0379559\n\n# number of significant SVGs\ntable(rowData(spe_nnSVG)$padj &lt;= 0.05)\n\n\nFALSE  TRUE \n   46   152 \n\n# show results for top n SVGs\nrowData(spe_nnSVG)[order(rowData(spe_nnSVG)$rank)[1:6], ]\n\nDataFrame with 6 rows and 17 columns\n                              gene_id   gene_name    feature_type  sigma.sq\n                          &lt;character&gt; &lt;character&gt;     &lt;character&gt; &lt;numeric&gt;\nENSMUSG00000046447 ENSMUSG00000046447     Camk2n1 Gene Expression   1.88342\nENSMUSG00000053310 ENSMUSG00000053310        Nrgn Gene Expression   3.17506\nENSMUSG00000018593 ENSMUSG00000018593       Sparc Gene Expression   2.04163\nENSMUSG00000032532 ENSMUSG00000032532         Cck Gene Expression   2.98145\nENSMUSG00000070570 ENSMUSG00000070570     Slc17a7 Gene Expression   2.64081\nENSMUSG00000024617 ENSMUSG00000024617      Camk2a Gene Expression   1.41249\n                        tau.sq       phi    loglik   runtime      mean\n                     &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSMUSG00000046447 6.28372e-02   2.05206   -99.021     0.021   5.35338\nENSMUSG00000053310 2.47772e-01   3.26420  -151.225     0.022   4.85871\nENSMUSG00000018593 7.63186e-02   3.68722  -124.793     0.021   3.61331\nENSMUSG00000032532 2.98145e-08   5.07869  -147.464     0.018   4.19282\nENSMUSG00000070570 3.20107e-01   4.15601  -155.620     0.018   3.62933\nENSMUSG00000024617 9.79965e-02   3.74573  -113.269     0.024   4.11652\n                         var     spcov   prop_sv loglik_lm   LR_stat      rank\n                   &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nENSMUSG00000046447   1.50820  0.256357  0.967714  -161.937  125.8321         1\nENSMUSG00000053310   3.71912  0.366737  0.927612  -207.066  111.6804         2\nENSMUSG00000018593   1.87664  0.395442  0.963966  -172.866   96.1453         3\nENSMUSG00000032532   2.72400  0.411820  1.000000  -191.496   88.0644         4\nENSMUSG00000070570   3.00604  0.447757  0.891889  -196.423   81.6050         5\nENSMUSG00000024617   1.17870  0.288711  0.935123  -149.612   72.6864         6\n                          pval        padj\n                     &lt;numeric&gt;   &lt;numeric&gt;\nENSMUSG00000046447 0.00000e+00 0.00000e+00\nENSMUSG00000053310 0.00000e+00 0.00000e+00\nENSMUSG00000018593 0.00000e+00 0.00000e+00\nENSMUSG00000032532 0.00000e+00 0.00000e+00\nENSMUSG00000070570 0.00000e+00 0.00000e+00\nENSMUSG00000024617 1.11022e-16 3.66374e-15\n\n# identify top-ranked SVG\nrowData(spe_nnSVG)$gene_name[which(rowData(spe_nnSVG)$rank == 1)]\n\n[1] \"Camk2n1\""
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#dimensionality-reduction",
    "href": "chapters/workflow-Visium-mouseCoronal.html#dimensionality-reduction",
    "title": "18  Mouse coronal workflow",
    "section": "18.9 Dimensionality reduction",
    "text": "18.9 Dimensionality reduction\nRun principal component analysis (PCA) on the set of top HVGs using scater (McCarthy et al. 2017), and retain the top 50 principal components (PCs) for downstream analyses. Also run UMAP on the top 50 PCs, and retain the top 2 UMAP components for visualization purposes.\n\n# compute PCA\nset.seed(123)\nspe &lt;- runPCA(spe, subset_row = top_hvgs)\n\nreducedDimNames(spe)\n\n[1] \"PCA\"\n\ndim(reducedDim(spe, \"PCA\"))\n\n[1] 2683   50\n\n\n\n# compute UMAP on top 50 PCs\nset.seed(123)\nspe &lt;- runUMAP(spe, dimred = \"PCA\")\n\nreducedDimNames(spe)\n\n[1] \"PCA\"  \"UMAP\"\n\ndim(reducedDim(spe, \"UMAP\"))\n\n[1] 2683    2\n\n# update column names for easier plotting\ncolnames(reducedDim(spe, \"UMAP\")) &lt;- paste0(\"UMAP\", 1:2)"
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#clustering",
    "href": "chapters/workflow-Visium-mouseCoronal.html#clustering",
    "title": "18  Mouse coronal workflow",
    "section": "18.10 Clustering",
    "text": "18.10 Clustering\nPerform clustering to define cell types. We apply graph-based clustering using the Walktrap method implemented in scran (Lun, McCarthy, and Marioni 2016), applied to the top 50 PCs calculated on the set of top HVGs.\n\n# graph-based clustering\nset.seed(123)\nk &lt;- 10\ng &lt;- buildSNNGraph(spe, k = k, use.dimred = \"PCA\")\ng_walk &lt;- igraph::cluster_walktrap(g)\nclus &lt;- g_walk$membership\ntable(clus)\n\nclus\n  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20 \n218 255 176 179  60 127 240 217  83  77 271 100 241 125  57 160  23  22  21  31 \n\n# store cluster labels in column 'label' in colData\ncolLabels(spe) &lt;- factor(clus)\n\nVisualize the clusters by plotting in (i) spatial (x-y) coordinates on the tissue slide, and (ii) UMAP dimensions.\n\n# define custom color palette\ncolors &lt;- unname(palette.colors(palette = \"Polychrome 36\"))\n\n# plot clusters in spatial x-y coordinates\nplotSpots(spe, annotate = \"label\", \n          pal = colors)\n\n\n\n\n\n# plot clusters in UMAP dimensions\nplotDimRed(spe, plot_type = \"UMAP\", \n           annotate = \"label\", pal = colors)"
  },
  {
    "objectID": "chapters/workflow-Visium-mouseCoronal.html#differential-expression",
    "href": "chapters/workflow-Visium-mouseCoronal.html#differential-expression",
    "title": "18  Mouse coronal workflow",
    "section": "18.11 Differential expression",
    "text": "18.11 Differential expression\nIdentify marker genes by testing for differential gene expression between clusters, using the binomial test implemented in findMarkers in scran (Lun, McCarthy, and Marioni 2016).\n\n# set gene names as row names for easier plotting\nrownames(spe) &lt;- rowData(spe)$gene_name\n\n# test for marker genes\nmarkers &lt;- findMarkers(spe, test = \"binom\", direction = \"up\")\n\n# returns a list with one DataFrame per cluster\nmarkers\n\nList of length 20\nnames(20): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n\n\n\nlibrary(pheatmap)\n\n\n# plot log-fold changes for one cluster over all other clusters\n# selecting cluster 5\ninteresting &lt;- markers[[5]]\nbest_set &lt;- interesting[interesting$Top &lt;= 5, ]\nlogFCs &lt;- getMarkerEffects(best_set)\n\npheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))\n\n\n\n\n\n# plot log-transformed normalized expression of top genes for one cluster\ntop_genes &lt;- head(rownames(interesting))\n\nplotExpression(spe, x = \"label\", features = top_genes)\n\n\n\n\n\n\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. “A Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.” F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2.\n\n\nMcCarthy, Davis J., Kieran R. Campbell, Aaron T. L. Lun, and Quin F. Wills. 2017. “Scater: Pre-Processing, Quality Control, Normalization and Visualization of Single-Cell RNA-seq Data in R.” Bioinformatics 33 (8): 1179–86. https://doi.org/10.1093/bioinformatics/btw777.\n\n\nWeber, Lukas M., Arkajyoti Saha, Abhirup Datta, Kasper D. Hansen, and Stephanie C. Hicks. 2023. “nnSVG for the Scalable Identification of Spatially Variable Genes Using Nearest-Neighbor Gaussian Processes.” Nature Communications 14: 4059. https://doi.org/10.1038/s41467-023-39748-z."
  },
  {
    "objectID": "chapters/workflow-Visium-spatialLIBD.html#overview",
    "href": "chapters/workflow-Visium-spatialLIBD.html#overview",
    "title": "19  spatialLIBD workflow",
    "section": "19.1 Overview",
    "text": "19.1 Overview\nIn the previous workflow, Chapter 17, you practiced some of the basics with a portion of the postmortem human brain dataset Maynard et al. (2021). The goal of this workflow is to learn what steps you need to carry out in order to create an interactive website to visualize this type of data. For this, we’ll use the spatialLIBD Bioconductor package Pardo et al. (2022).\n\n\n\n\n\nspatialLIBD overview. Source: Pardo et al. (2022)."
  },
  {
    "objectID": "chapters/workflow-Visium-spatialLIBD.html#spatiallibd",
    "href": "chapters/workflow-Visium-spatialLIBD.html#spatiallibd",
    "title": "19  spatialLIBD workflow",
    "section": "19.2 spatialLIBD",
    "text": "19.2 spatialLIBD\n\n19.2.1 Why use spatialLIBD?\nBefore we dive into the R code, let’s first revisit why you might want to use spatialLIBD. This package has a function, spatialLIBD::run_app(spe), which will create an interactive website using a SpatialExperiment object (spe). The interactive website it creates has several features that were initially designed for a specific dataset Maynard et al. (2021) and later made flexible for any dataset Pardo et al. (2022). These features include panels to visualize spots from the Visium platform by 10x Genomics:\n\nfor one tissue section at a time, either with interactive or static versions\nmultiple tissue sections at a time, either interactively or statically\n\nBoth options work with continuous and discrete variables such as the gene expression and clusters, respectively. The interactive version for discrete variables such as clusters is useful if you want to manually annotate Visium spots, as it was done in the initial project Maynard et al. (2021). spatialLIBD allows users to download the annotated spots and resume your spot annotation work later.\n\n\n\n\n\nScreenshot of the ‘clusters (interactive)’ section of the ‘spot-level data’ panel created with the full spatialLIBD dataset. The website was created with spatialLIBD::run_app(spatialLIBD::fetch_data('spe')) version 1.4.0 and then using the lasso selection, we selected a set of spots in the UMAP interactive plot colored by the estimated number of cells per spot (cell_count) on the bottom left, which automatically updated the other three plots.\n\n\n\n\nVisualizing genes or clusters across multiple tissue sections can be quite useful. For example, here we show the expression levels of PCP4 across two sets of spatially adjacent replicates. PCP4 is a marker gene for layer 5 in the grey matter of the dorsolateral prefrontal cortex (DLPFC) in the human brain. Spatially adjacent replicates are about 10 microns apart from each other and visualizations like the one below help assess the technical variability in the Visium technology.\n\n\n\n\n\nScreenshot of the ‘gene grid (static)’ section of the ‘spot-level data’ panel created with the full spatialLIBD dataset. The website was created with spatialLIBD::run_app(spatialLIBD::fetch_data('spe')) version 1.4.0, selecting the PCP4 gene, selecting the paper gene color scale, changing the number of rows and columns in the grid 2, selecting two pairs of spatially adjacent replicate samples (151507, 151508, 151673, and 151674), and clicking on the upgrade grid plot button. Note that the default viridis gene color scale is color-blind friendly.\n\n\n\n\nYou can try out a spatialLIBD-powered website yourself by opening it on your browser 1.\n\n\n19.2.2 Want to learn more about spatialLIBD?\nIf you are interested in learning more about spatialLIBD, please check the spatialLIBD Bioconductor landing page or the pkgdown documentation website. In particular, we have two vignettes documents:\n\nIntroduction to spatialLIBD\nUsing spatialLIBD with 10x Genomics public datasets\n\nYou can also read more about spatialLIBD in the associated publication.\n\ncitation(\"spatialLIBD\")[1]\n\nPardo B, Spangler A, Weber LM, Hicks SC, Jaffe AE, Martinowich K,\nMaynard KR, Collado-Torres L (2022). \"spatialLIBD: an R/Bioconductor\npackage to visualize spatially-resolved transcriptomics data.\" _BMC\nGenomics_. doi:10.1186/s12864-022-08601-w\n&lt;https://doi.org/10.1186/s12864-022-08601-w&gt;,\n&lt;https://doi.org/10.1186/s12864-022-08601-w&gt;.\n\nA BibTeX entry for LaTeX users is\n\n  @Article{,\n    title = {spatialLIBD: an R/Bioconductor package to visualize spatially-resolved transcriptomics data},\n    author = {Brenda Pardo and Abby Spangler and Lukas M. Weber and Stephanie C. Hicks and Andrew E. Jaffe and Keri Martinowich and Kristen R. Maynard and Leonardo Collado-Torres},\n    year = {2022},\n    journal = {BMC Genomics},\n    doi = {10.1186/s12864-022-08601-w},\n    url = {https://doi.org/10.1186/s12864-022-08601-w},\n  }\n\n\n\n19.2.2.1 Recordings\nIf you prefer to watch recordings of presentations related to the dataset Maynard et al. (2021) or spatialLIBD Pardo et al. (2022), check the following 2:\n\n\nThese slides were part of our 2021-04-27 webinar for BioTuring that you can watch on YouTube:\n\n\nA recording of an earlier version of this talk is also available on YouTube.\n\n\nYou might also be interested in this video demonstration of spatialLIBD for the LIBD rstats club."
  },
  {
    "objectID": "chapters/workflow-Visium-spatialLIBD.html#code-prerequisites",
    "href": "chapters/workflow-Visium-spatialLIBD.html#code-prerequisites",
    "title": "19  spatialLIBD workflow",
    "section": "19.3 Code prerequisites",
    "text": "19.3 Code prerequisites\nOk, let’s get started! First we need to re-create the spe object from the Chapter 17 in the previous chapter. That chapter included code for visualizing results along the way, which we’ll skip here. Thus, we’ll use the following packages in addition to spatialLIBD:\n\nSpatialExperiment: for storing our data in a common object\nSTexampleData: for accessing the example data\nscater: for quality control checks\nscran: for normalization, dimension reduction, and clustering\nigraph: for clustering algorithms\nBiocFileCache: for downloading and storing data\nrtracklayer: for importing gene annotation files\nlobstr: for checking object memory usage\n\nYou’ll need to have the R version compatible with bioc-release 3 installed in your computer, as documented by Bioconductor. Alternatively, you can use the Bioconductor docker images. Next, if you haven’t installed these packages, please do so with the following R code.\n\nif (!requireNamespace(\"BiocManager\", quietly = TRUE)) {\n    install.packages(\"BiocManager\")\n}\n\n## Check that you have a valid installation\nBiocManager::valid()\n\n## Install the required R packages for this workflow\nBiocManager::install(c(\n    \"SpatialExperiment\",\n    \"STexampleData\",\n    \"scater\",\n    \"scran\",\n    \"igraph\",\n    \"BiocFileCache\",\n    \"rtracklayer\",\n    \"lobstr\",\n    \"spatialLIBD\"\n))\n\nWe can now run the following R code to re-make the spe object from the Chapter 17. This will take a bit of time.\n\n## Load packages required for the\n## \"Visium human DLPFC workflow\"\nlibrary(\"SpatialExperiment\")\nlibrary(\"STexampleData\")\nlibrary(\"scater\")\nlibrary(\"scran\")\nlibrary(\"igraph\")\nlibrary(\"BiocFileCache\")\nlibrary(\"rtracklayer\")\nlibrary(\"lobstr\")\nlibrary(\"spatialLIBD\")\n\n## Start tracking time\ntime_start &lt;- Sys.time()\n\n# load object\nspe &lt;- Visium_humanDLPFC()\n\n# subset to keep only spots over tissue\nspe &lt;- spe[, colData(spe)$in_tissue == 1]\n\n# identify mitochondrial genes\nis_mito &lt;- grepl(\"(^MT-)|(^mt-)\", rowData(spe)$gene_name)\n\n# calculate per-spot QC metrics and store in colData\nspe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito))\n\n# select QC thresholds\nqc_lib_size &lt;- colData(spe)$sum &lt; 600\nqc_detected &lt;- colData(spe)$detected &lt; 400\nqc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 28\nqc_cell_count &lt;- colData(spe)$cell_count &gt; 10\n\n# combined set of discarded spots\ndiscard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count\n\n# store in object\ncolData(spe)$discard &lt;- discard\n\n# filter low-quality spots\nspe &lt;- spe[, !colData(spe)$discard]\n\n# calculate logcounts using library size factors\nspe &lt;- logNormCounts(spe)\n\n# remove mitochondrial genes\nspe &lt;- spe[!is_mito, ]\n\n# fit mean-variance relationship\ndec &lt;- modelGeneVar(spe)\n\n# select top HVGs\ntop_hvgs &lt;- getTopHVGs(dec, prop = 0.1)\n\n# compute PCA\nset.seed(123)\nspe &lt;- runPCA(spe, subset_row = top_hvgs)\n\n# compute UMAP on top 50 PCs\nset.seed(123)\nspe &lt;- runUMAP(spe, dimred = \"PCA\")\n\n# update column names for easier plotting\ncolnames(reducedDim(spe, \"UMAP\")) &lt;- paste0(\"UMAP\", 1:2)\n\n# graph-based clustering\nset.seed(123)\nk &lt;- 10\ng &lt;- buildSNNGraph(spe, k = k, use.dimred = \"PCA\")\ng_walk &lt;- igraph::cluster_walktrap(g)\nclus &lt;- g_walk$membership\n\n# store cluster labels in column 'label' in colData\ncolLabels(spe) &lt;- factor(clus)\n\n# set gene names as row names for easier plotting\nrownames(spe) &lt;- rowData(spe)$gene_name\n\n# test for marker genes\nmarkers &lt;- findMarkers(spe, test = \"binom\", direction = \"up\")\n\n## Find the interesting markers for each cluster\ninteresting &lt;- sapply(markers, function(x) x$Top &lt;= 5)\ncolnames(interesting) &lt;- paste0(\"gene_interest_\", seq_len(length(markers)))\nrowData(spe) &lt;- cbind(rowData(spe), interesting)\n\n## How long this code took to run\ntime_prereqs &lt;- Sys.time()\ntime_prereqs - time_start\n\nTime difference of 1.28797 mins"
  },
  {
    "objectID": "chapters/workflow-Visium-spatialLIBD.html#prepare-for-spatiallibd",
    "href": "chapters/workflow-Visium-spatialLIBD.html#prepare-for-spatiallibd",
    "title": "19  spatialLIBD workflow",
    "section": "19.4 Prepare for spatialLIBD",
    "text": "19.4 Prepare for spatialLIBD\nNow that we have a spe object with quality control information, dimension reduction results, clustering data, among other things, we can proceed to visualize the object using spatialLIBD. Well, almost. First we need to modify the spe object, similar to steps we need to carry out when using spatialLIBD with 10x Genomics public datasets\n\n19.4.1 Basic information\n\n## Add some information used by spatialLIBD\nspe$key &lt;- paste0(spe$sample_id, \"_\", colnames(spe))\nspe$sum_umi &lt;- colSums(counts(spe))\nspe$sum_gene &lt;- colSums(counts(spe) &gt; 0)\n\n\n\n19.4.2 Gene annotation\nSince the gene information is missing, we’ll add the gene annotation data from Gencode although you would ideally add this information from the same gene annotation you used for running spaceranger.\n\n## Download the Gencode v32 GTF file and cache it\nbfc &lt;- BiocFileCache::BiocFileCache()\ngtf_cache &lt;- BiocFileCache::bfcrpath(\n    bfc,\n    paste0(\n        \"ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/\",\n        \"release_32/gencode.v32.annotation.gtf.gz\"\n    )\n)\n\n## Show the GTF cache location\ngtf_cache\n\n                                                                                                   BFC11 \n\"/Users/lukas/Library/Caches/org.R-project.R/R/BiocFileCache/693465337611_gencode.v32.annotation.gtf.gz\" \n\n## Import into R (takes ~1 min)\ngtf &lt;- rtracklayer::import(gtf_cache)\n\n## Subset to genes only\ngtf &lt;- gtf[gtf$type == \"gene\"]\n\n## Remove the .x part of the gene IDs\ngtf$gene_id &lt;- gsub(\"\\\\..*\", \"\", gtf$gene_id)\n\n## Set the names to be the gene IDs\nnames(gtf) &lt;- gtf$gene_id\n\n## Match the genes\nmatch_genes &lt;- match(rowData(spe)$gene_id, gtf$gene_id)\ntable(is.na(match_genes))\n\n\nFALSE  TRUE \n33267   258 \n\n## Drop the few genes for which we don't have information\nspe &lt;- spe[!is.na(match_genes), ]\nmatch_genes &lt;- match_genes[!is.na(match_genes)]\n\n## Keep only some columns from the gtf\nmcols(gtf) &lt;- mcols(gtf)[, c(\"source\", \"type\", \"gene_id\", \"gene_name\", \"gene_type\")]\n\n## Save the \"interest\"ing columns from our original spe object\ninteresting &lt;- rowData(spe)[, grepl(\"interest\", colnames(rowData(spe)))]\n\n## Add the gene info to our SPE object\nrowRanges(spe) &lt;- gtf[match_genes]\n\n## Add back the \"interest\" coolumns\nrowData(spe) &lt;- cbind(rowData(spe), interesting)\n\n## Inspect the gene annotation data we added\nrowRanges(spe)\n\nGRanges object with 33267 ranges and 12 metadata columns:\n                  seqnames            ranges strand |   source     type\n                     &lt;Rle&gt;         &lt;IRanges&gt;  &lt;Rle&gt; | &lt;factor&gt; &lt;factor&gt;\n  ENSG00000243485     chr1       29554-31109      + |   HAVANA     gene\n  ENSG00000237613     chr1       34554-36081      - |   HAVANA     gene\n  ENSG00000186092     chr1       65419-71585      + |   HAVANA     gene\n  ENSG00000238009     chr1      89295-133723      - |   HAVANA     gene\n  ENSG00000239945     chr1       89551-91105      - |   HAVANA     gene\n              ...      ...               ...    ... .      ...      ...\n  ENSG00000160298    chr21 46300181-46323875      - |   HAVANA     gene\n  ENSG00000160299    chr21 46324141-46445769      + |   HAVANA     gene\n  ENSG00000160305    chr21 46458891-46570015      + |   HAVANA     gene\n  ENSG00000160307    chr21 46598604-46605208      - |   HAVANA     gene\n  ENSG00000160310    chr21 46635595-46665124      + |   HAVANA     gene\n                          gene_id   gene_name      gene_type gene_interest_1\n                      &lt;character&gt; &lt;character&gt;    &lt;character&gt;       &lt;logical&gt;\n  ENSG00000243485 ENSG00000243485 MIR1302-2HG         lncRNA            TRUE\n  ENSG00000237613 ENSG00000237613     FAM138A         lncRNA            TRUE\n  ENSG00000186092 ENSG00000186092       OR4F5 protein_coding            TRUE\n  ENSG00000238009 ENSG00000238009  AL627309.1         lncRNA            TRUE\n  ENSG00000239945 ENSG00000239945  AL627309.3         lncRNA            TRUE\n              ...             ...         ...            ...             ...\n  ENSG00000160298 ENSG00000160298    C21orf58 protein_coding           FALSE\n  ENSG00000160299 ENSG00000160299        PCNT protein_coding           FALSE\n  ENSG00000160305 ENSG00000160305       DIP2A protein_coding           FALSE\n  ENSG00000160307 ENSG00000160307       S100B protein_coding           FALSE\n  ENSG00000160310 ENSG00000160310       PRMT2 protein_coding           FALSE\n                  gene_interest_2 gene_interest_3 gene_interest_4\n                        &lt;logical&gt;       &lt;logical&gt;       &lt;logical&gt;\n  ENSG00000243485            TRUE            TRUE            TRUE\n  ENSG00000237613            TRUE            TRUE            TRUE\n  ENSG00000186092            TRUE            TRUE            TRUE\n  ENSG00000238009            TRUE            TRUE            TRUE\n  ENSG00000239945            TRUE            TRUE            TRUE\n              ...             ...             ...             ...\n  ENSG00000160298           FALSE           FALSE           FALSE\n  ENSG00000160299           FALSE           FALSE           FALSE\n  ENSG00000160305           FALSE           FALSE           FALSE\n  ENSG00000160307           FALSE           FALSE           FALSE\n  ENSG00000160310           FALSE           FALSE           FALSE\n                  gene_interest_5 gene_interest_6 gene_interest_7\n                        &lt;logical&gt;       &lt;logical&gt;       &lt;logical&gt;\n  ENSG00000243485            TRUE            TRUE            TRUE\n  ENSG00000237613            TRUE            TRUE            TRUE\n  ENSG00000186092            TRUE            TRUE            TRUE\n  ENSG00000238009            TRUE            TRUE            TRUE\n  ENSG00000239945            TRUE            TRUE            TRUE\n              ...             ...             ...             ...\n  ENSG00000160298           FALSE           FALSE           FALSE\n  ENSG00000160299           FALSE           FALSE           FALSE\n  ENSG00000160305           FALSE           FALSE           FALSE\n  ENSG00000160307           FALSE           FALSE           FALSE\n  ENSG00000160310           FALSE           FALSE           FALSE\n  -------\n  seqinfo: 25 sequences from an unspecified genome; no seqlengths\n\n\nNow that we have the gene annotation information, we can use it to add a few more pieces to our spe object that spatialLIBD will use. For example, we want to enable users to search genes by either their gene symbol or their Ensembl ID. We also like to visualize the amount and percent of the mitochondrial gene expression.\n\n## Add information used by spatialLIBD\nrowData(spe)$gene_search &lt;- paste0(\n    rowData(spe)$gene_name, \"; \", rowData(spe)$gene_id\n)\n\n## Compute chrM expression and chrM expression ratio\nis_mito &lt;- which(seqnames(spe) == \"chrM\")\nspe$expr_chrM &lt;- colSums(counts(spe)[is_mito, , drop = FALSE])\nspe$expr_chrM_ratio &lt;- spe$expr_chrM / spe$sum_umi\n\n\n\n19.4.3 Extra information and filtering\nNow that we have the full gene annotation information we need, we can proceed to add some last touches as well as filter the object to reduce the memory required for visualizing the data.\n\n## Add a variable for saving the manual annotations\nspe$ManualAnnotation &lt;- \"NA\"\n\n## Remove genes with no data\nno_expr &lt;- which(rowSums(counts(spe)) == 0)\n\n## Number of genes with no counts\nlength(no_expr)\n\n[1] 11596\n\n## Compute the percent of genes with no counts\nlength(no_expr) / nrow(spe) * 100\n\n[1] 34.85737\n\nspe &lt;- spe[-no_expr, , drop = FALSE]\n\n## Remove spots without counts\nsummary(spe$sum_umi)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    537    2414    3466    3870    4938   15862 \n\n## If we had spots with no counts, we would remove them\nif (any(spe$sum_umi == 0)) {\n    spots_no_counts &lt;- which(spe$sum_umi == 0)\n    ## Number of spots with no counts\n    print(length(spots_no_counts))\n    ## Percent of spots with no counts\n    print(length(spots_no_counts) / ncol(spe) * 100)\n    spe &lt;- spe[, -spots_no_counts, drop = FALSE]\n}\n\nWe think that we are ready to proceed to making our interactive website. Let’s use the spatialLIBD::check_spe() function, just to verify that we are right. If we aren’t, then it’ll try to tell us what we missed.\n\n## Run check_spe() function\nspatialLIBD::check_spe(spe)\n\nclass: SpatialExperiment \ndim: 21671 3524 \nmetadata(0):\nassays(2): counts logcounts\nrownames(21671): ENSG00000243485 ENSG00000238009 ... ENSG00000160307\n  ENSG00000160310\nrowData names(13): source type ... gene_interest_7 gene_search\ncolnames(3524): AAACAAGTATCTCCCA-1 AAACACCAATAACTGC-1 ...\n  TTGTTTCCATACAACT-1 TTGTTTGTGTAAATTC-1\ncolData names(22): barcode_id sample_id ... expr_chrM_ratio\n  ManualAnnotation\nreducedDimNames(2): PCA UMAP\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(4): sample_id image_id data scaleFactor\n\n## End tracking time\ntime_end &lt;- Sys.time()\n\n## How long this code took to run\ntime_end - time_prereqs\n\nTime difference of 34.72107 secs\n\n\nCreating our final spe object took 1.86665423313777 to run. So you might want to save this object for later use.\n\nsaveRDS(spe, file = \"spe_workflow_Visium_spatialLIBD.rds\")\n\nYou can then re-load it with the following code on a later session.\n\nspe &lt;- readRDS(\"spe_workflow_Visium_spatialLIBD.rds\")"
  },
  {
    "objectID": "chapters/workflow-Visium-spatialLIBD.html#explore-the-data",
    "href": "chapters/workflow-Visium-spatialLIBD.html#explore-the-data",
    "title": "19  spatialLIBD workflow",
    "section": "19.5 Explore the data",
    "text": "19.5 Explore the data\nIn order to visualize the data, we can then use spatialLIBD::vis_gene(). Note that we didn’t need to do all that hard work just for that. But well, this is a nice quick check before we try launching our interactive website.\n\n## Sum of UMI\nspatialLIBD::vis_gene(\n    spe = spe,\n    sampleid = \"sample_151673\",\n    geneid = \"sum_umi\"\n)\n\n\n\n## PCP4, a layer 5 marker gene\nspatialLIBD::vis_gene(\n    spe = spe,\n    sampleid = \"sample_151673\",\n    geneid = rowData(spe)$gene_search[which(rowData(spe)$gene_name == \"PCP4\")]\n)\n\n\n\n\nAs we wanted let’s proceed to visualize the data interactively with a spatialLIBD-powered website. We have lots of variables to choose from. We’ll specify which are our continuous and discrete variables in our spatialLIBD::run_app() call.\n\n## Explore all the variables we can use\ncolData(spe)\n\nDataFrame with 3524 rows and 22 columns\n                           barcode_id     sample_id in_tissue array_row\n                          &lt;character&gt;   &lt;character&gt; &lt;integer&gt; &lt;integer&gt;\nAAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 sample_151673         1        50\nAAACACCAATAACTGC-1 AAACACCAATAACTGC-1 sample_151673         1        59\nAAACAGAGCGACTCCT-1 AAACAGAGCGACTCCT-1 sample_151673         1        14\nAAACAGCTTTCAGAAG-1 AAACAGCTTTCAGAAG-1 sample_151673         1        43\nAAACAGGGTCTATATT-1 AAACAGGGTCTATATT-1 sample_151673         1        47\n...                               ...           ...       ...       ...\nTTGTTGTGTGTCAAGA-1 TTGTTGTGTGTCAAGA-1 sample_151673         1        31\nTTGTTTCACATCCAGG-1 TTGTTTCACATCCAGG-1 sample_151673         1        58\nTTGTTTCATTAGTCTA-1 TTGTTTCATTAGTCTA-1 sample_151673         1        60\nTTGTTTCCATACAACT-1 TTGTTTCCATACAACT-1 sample_151673         1        45\nTTGTTTGTGTAAATTC-1 TTGTTTGTGTAAATTC-1 sample_151673         1         7\n                   array_col ground_truth cell_count       sum  detected\n                   &lt;integer&gt;  &lt;character&gt;  &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt;\nAAACAAGTATCTCCCA-1       102       Layer3          6      8458      3586\nAAACACCAATAACTGC-1        19           WM          5      3769      1960\nAAACAGAGCGACTCCT-1        94       Layer3          2      5433      2424\nAAACAGCTTTCAGAAG-1         9       Layer5          4      4278      2264\nAAACAGGGTCTATATT-1        13       Layer6          6      4004      2178\n...                      ...          ...        ...       ...       ...\nTTGTTGTGTGTCAAGA-1        77       Layer5          3      3966      1982\nTTGTTTCACATCCAGG-1        42           WM          3      4324      2170\nTTGTTTCATTAGTCTA-1        30           WM          4      2761      1560\nTTGTTTCCATACAACT-1        27       Layer6          3      2322      1343\nTTGTTTGTGTAAATTC-1        51       Layer2          5      6281      2927\n                   subsets_mito_sum subsets_mito_detected subsets_mito_percent\n                          &lt;numeric&gt;             &lt;numeric&gt;            &lt;numeric&gt;\nAAACAAGTATCTCCCA-1             1407                    13              16.6351\nAAACACCAATAACTGC-1              430                    13              11.4089\nAAACAGAGCGACTCCT-1             1316                    13              24.2223\nAAACAGCTTTCAGAAG-1              651                    12              15.2174\nAAACAGGGTCTATATT-1              621                    13              15.5095\n...                             ...                   ...                  ...\nTTGTTGTGTGTCAAGA-1              789                    13             19.89410\nTTGTTTCACATCCAGG-1              370                    12              8.55689\nTTGTTTCATTAGTCTA-1              314                    12             11.37269\nTTGTTTCCATACAACT-1              476                    13             20.49957\nTTGTTTGTGTAAATTC-1              991                    13             15.77774\n                       total   discard sizeFactor    label\n                   &lt;numeric&gt; &lt;logical&gt;  &lt;numeric&gt; &lt;factor&gt;\nAAACAAGTATCTCCCA-1      8458     FALSE   1.822839        3\nAAACACCAATAACTGC-1      3769     FALSE   0.812282        1\nAAACAGAGCGACTCCT-1      5433     FALSE   1.170902        3\nAAACAGCTTTCAGAAG-1      4278     FALSE   0.921980        3\nAAACAGGGTCTATATT-1      4004     FALSE   0.862928        6\n...                      ...       ...        ...      ...\nTTGTTGTGTGTCAAGA-1      3966     FALSE   0.854739        4\nTTGTTTCACATCCAGG-1      4324     FALSE   0.931894        1\nTTGTTTCATTAGTCTA-1      2761     FALSE   0.595041        1\nTTGTTTCCATACAACT-1      2322     FALSE   0.500429        2\nTTGTTTGTGTAAATTC-1      6281     FALSE   1.353660        7\n                                      key   sum_umi  sum_gene expr_chrM\n                              &lt;character&gt; &lt;numeric&gt; &lt;integer&gt; &lt;numeric&gt;\nAAACAAGTATCTCCCA-1 sample_151673_AAACAA..      7051      3573         0\nAAACACCAATAACTGC-1 sample_151673_AAACAC..      3339      1947         0\nAAACAGAGCGACTCCT-1 sample_151673_AAACAG..      4117      2411         0\nAAACAGCTTTCAGAAG-1 sample_151673_AAACAG..      3627      2252         0\nAAACAGGGTCTATATT-1 sample_151673_AAACAG..      3383      2165         0\n...                                   ...       ...       ...       ...\nTTGTTGTGTGTCAAGA-1 sample_151673_TTGTTG..      3177      1969         0\nTTGTTTCACATCCAGG-1 sample_151673_TTGTTT..      3954      2158         0\nTTGTTTCATTAGTCTA-1 sample_151673_TTGTTT..      2447      1548         0\nTTGTTTCCATACAACT-1 sample_151673_TTGTTT..      1846      1330         0\nTTGTTTGTGTAAATTC-1 sample_151673_TTGTTT..      5290      2914         0\n                   expr_chrM_ratio ManualAnnotation\n                         &lt;numeric&gt;      &lt;character&gt;\nAAACAAGTATCTCCCA-1               0               NA\nAAACACCAATAACTGC-1               0               NA\nAAACAGAGCGACTCCT-1               0               NA\nAAACAGCTTTCAGAAG-1               0               NA\nAAACAGGGTCTATATT-1               0               NA\n...                            ...              ...\nTTGTTGTGTGTCAAGA-1               0               NA\nTTGTTTCACATCCAGG-1               0               NA\nTTGTTTCATTAGTCTA-1               0               NA\nTTGTTTCCATACAACT-1               0               NA\nTTGTTTGTGTAAATTC-1               0               NA\n\n## Run our shiny app\nif (interactive()) {\n    spatialLIBD::run_app(\n        spe,\n        sce_layer = NULL,\n        modeling_results = NULL,\n        sig_genes = NULL,\n        title = \"OSTA spatialLIBD workflow example\",\n        spe_discrete_vars = c(\"ground_truth\", \"label\", \"ManualAnnotation\"),\n        spe_continuous_vars = c(\n            \"cell_count\",\n            \"sum_umi\",\n            \"sum_gene\",\n            \"expr_chrM\",\n            \"expr_chrM_ratio\",\n            \"sum\",\n            \"detected\",\n            \"subsets_mito_sum\",\n            \"subsets_mito_detected\",\n            \"subsets_mito_percent\",\n            \"total\",\n            \"sizeFactor\"\n        ),\n        default_cluster = \"label\"\n    )\n}\n\n\n\n\n\n\nScreenshot of the ‘clusters (interactive)’ section of the ‘spot-level data’ panel created with with the data from this workflow."
  },
  {
    "objectID": "chapters/workflow-Visium-spatialLIBD.html#sharing-your-website",
    "href": "chapters/workflow-Visium-spatialLIBD.html#sharing-your-website",
    "title": "19  spatialLIBD workflow",
    "section": "19.6 Sharing your website",
    "text": "19.6 Sharing your website\nNow that you have created a spatialLIBD-powered website, you might be interested in sharing it. To do so, it’ll be useful to have saved a small spe object using saveRDS() like we did earlier. The smaller the object, the better in terms of performance. For example, you might want to remove the lowly expressed genes to save space. One function you can use to measure how big your object is is lobstr::obj_size() as shown below.\n\n## Object size\nlobstr::obj_size(spe) / 1024^2 ## Convert to MB\n\n293.12 B\n\n\nIf your data is small enough, you might want to share your website by hosting on shinyapps.io by RStudio, which you can try for free. Once you have created your account, you’ll want to create an app.R file like the one we have on the spatialLIBD_demo directory.\n\n\nlibrary(\"spatialLIBD\")\n library(\"markdown\") # for shinyapps.io\n \n ## spatialLIBD uses golem\n options(\"golem.app.prod\" = TRUE)\n \n ## You need this to enable shinyapps to install Bioconductor packages\n options(repos = BiocManager::repositories())\n \n ## Load the data\n spe &lt;- readRDS(\"spe_workflow_Visium_spatialLIBD.rds\")\n \n ## Deploy the website\n spatialLIBD::run_app(\n     spe,\n     sce_layer = NULL,\n     modeling_results = NULL,\n     sig_genes = NULL,\n     title = \"OSTA spatialLIBD workflow example\",\n     spe_discrete_vars = c(\"ground_truth\", \"label\", \"ManualAnnotation\"),\n     spe_continuous_vars = c(\n         \"cell_count\",\n         \"sum_umi\",\n         \"sum_gene\",\n         \"expr_chrM\",\n         \"expr_chrM_ratio\",\n         \"sum\",\n         \"detected\",\n         \"subsets_mito_sum\",\n         \"subsets_mito_detected\",\n         \"subsets_mito_percent\",\n         \"total\",\n         \"sizeFactor\"\n     ),\n     default_cluster = \"label\",\n     docs_path = \"www\"\n )\n\n\nYou can then open R in a new session in the same directory where you saved the app.R file, run the code and click on the “publish” blue button at the top right of your RStudio window. You’ll then need to upload the app.R file, your spe_workflow_Visium_spatialLIBD.rds file and the files under the www directory which enable you to customize your spatialLIDB website.\n\n\n\n\n\nScreenshot of the RStudio window for publishing your spatialLIBD-powered website to shinyapps.io\n\n\n\n\nThe RStudio prompts will guide you along the process for authenticating to your shinyapps.io account, which will involve copy pasting some code that starts with rsconnect::setAccountInfo(). Alternatively, you can create a deploy.R script and write the code for uploading your files to shinyapps.io as shown below.\n\n\nlibrary('rsconnect')\n \n ## Or you can go to your shinyapps.io account and copy this\n ## Here we do this to keep our information hidden.\n load(\".deploy_info.Rdata\")\n rsconnect::setAccountInfo(\n     name = deploy_info$name,\n     token = deploy_info$token,\n     secret = deploy_info$secret\n )\n \n ## You need this to enable shinyapps to install Bioconductor packages\n options(repos = BiocManager::repositories())\n \n ## Deploy the app, that is, upload it to shinyapps.io\n rsconnect::deployApp(\n     appFiles = c(\n         \"app.R\",\n         \"spe_workflow_Visium_spatialLIBD.rds\",\n         dir(\"www\", full.names = TRUE)\n     ),\n     appName = 'OSTA_spatialLIBD_demo',\n     account = 'libd',\n     server = 'shinyapps.io'\n )\n\n\nNote that we have copied the default www directory files from the spatialLIBD repository and adapted them to our liking. We then use these files with spatialLIBD::run_app(docs_path) in our app.R script. These files help us control portions of our spatialLIBD-powered website and customize it to our liking.\nIf you follow this workflow, you’ll end up with a website just like this one. In our case, we further configured our website through the shinyapps.io dashboard. We selected the following options:\n\nGeneral Instance Size: 3X-Large (8GB)\nAdvanced Max Worker Processes: 1\nAdvanced Max Connections: 15\n\nThe Max Worker Processes determines how many R sessions are open per instance. Then Max Connections specifies the number of connections to each R session. The Instance Size determines the memory available. In this case, 8000 / 300 is approximately 27, but we decided to be conservative and set the total number of users per instance to be 15. This is why it can be important to reduce the size of your spe object before sharing the website. Alternatively, you can rent an AWS Instance and deploy your app there, which is how http://spatial.libd.org/spatialLIBD is hosted along with these error configuration files."
  },
  {
    "objectID": "chapters/workflow-Visium-spatialLIBD.html#wrapping-up",
    "href": "chapters/workflow-Visium-spatialLIBD.html#wrapping-up",
    "title": "19  spatialLIBD workflow",
    "section": "19.7 Wrapping up",
    "text": "19.7 Wrapping up\nThank you for reading this far! In this workflow we showed you:\n\nwhy you might be interested in using spatialLIBD,\nwe re-used the spe object from the Chapter 17 chapter,\nwe adapted the spe object to make it compatible with spatialLIBD,\nwe created an interactive website in our laptops,\nwe shared the website with others using shinyapps.io.\n\nOverall, we hope that you found this information useful and we wish you the best luck with exploring and annotating your own Visium data!"
  },
  {
    "objectID": "chapters/workflow-Visium-spatialLIBD.html#r-session-information",
    "href": "chapters/workflow-Visium-spatialLIBD.html#r-session-information",
    "title": "19  spatialLIBD workflow",
    "section": "R session information",
    "text": "R session information\nHere’s the R session information for this workflow.\n\noptions(width = 120)\nsessioninfo::session_info()\n\n─ Session info ───────────────────────────────────────────────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.3 (2024-02-29)\n os       macOS Sonoma 14.3.1\n system   x86_64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       America/New_York\n date     2024-03-17\n pandoc   3.1.1 @ /Applications/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────────────────────────────────────────────\n package                * version   date (UTC) lib source\n abind                    1.4-5     2016-07-21 [1] CRAN (R 4.3.0)\n AnnotationDbi            1.64.1    2023-11-03 [1] Bioconductor\n AnnotationHub          * 3.10.0    2023-10-24 [1] Bioconductor\n attempt                  0.3.1     2020-05-03 [1] CRAN (R 4.3.0)\n beachmat                 2.18.1    2024-02-14 [1] Bioconductor 3.18 (R 4.3.2)\n beeswarm                 0.4.0     2021-06-01 [1] CRAN (R 4.3.0)\n benchmarkme              1.0.8     2022-06-12 [1] CRAN (R 4.3.0)\n benchmarkmeData          1.0.4     2020-04-23 [1] CRAN (R 4.3.0)\n Biobase                * 2.62.0    2023-10-24 [1] Bioconductor\n BiocFileCache          * 2.10.1    2023-10-26 [1] Bioconductor\n BiocGenerics           * 0.48.1    2023-11-01 [1] Bioconductor\n BiocIO                   1.12.0    2023-10-24 [1] Bioconductor\n BiocManager              1.30.22   2023-08-08 [1] CRAN (R 4.3.0)\n BiocNeighbors            1.20.1    2023-12-18 [1] Bioconductor 3.18 (R 4.3.2)\n BiocParallel             1.36.0    2023-10-24 [1] Bioconductor\n BiocSingular             1.18.0    2023-10-24 [1] Bioconductor\n BiocVersion              3.18.1    2023-11-15 [1] Bioconductor\n Biostrings               2.70.1    2023-10-25 [1] Bioconductor\n bit                      4.0.5     2022-11-15 [1] CRAN (R 4.3.0)\n bit64                    4.0.5     2020-08-30 [1] CRAN (R 4.3.0)\n bitops                   1.0-7     2021-04-24 [1] CRAN (R 4.3.0)\n blob                     1.2.4     2023-03-17 [1] CRAN (R 4.3.0)\n bluster                  1.12.0    2023-10-24 [1] Bioconductor\n bslib                    0.6.1     2023-11-28 [1] CRAN (R 4.3.0)\n cachem                   1.0.8     2023-05-01 [1] CRAN (R 4.3.0)\n cli                      3.6.2     2023-12-11 [1] CRAN (R 4.3.0)\n cluster                  2.1.6     2023-12-01 [1] CRAN (R 4.3.3)\n codetools                0.2-19    2023-02-01 [1] CRAN (R 4.3.3)\n colorspace               2.1-0     2023-01-23 [1] CRAN (R 4.3.0)\n config                   0.3.2     2023-08-30 [1] CRAN (R 4.3.0)\n cowplot                  1.1.3     2024-01-22 [1] CRAN (R 4.3.2)\n crayon                   1.5.2     2022-09-29 [1] CRAN (R 4.3.0)\n curl                     5.2.1     2024-03-01 [1] CRAN (R 4.3.2)\n data.table               1.14.10   2023-12-08 [1] CRAN (R 4.3.0)\n DBI                      1.2.2     2024-02-16 [1] CRAN (R 4.3.2)\n dbplyr                 * 2.4.0     2023-10-26 [1] CRAN (R 4.3.0)\n DelayedArray             0.28.0    2023-10-24 [1] Bioconductor\n DelayedMatrixStats       1.24.0    2023-10-24 [1] Bioconductor\n digest                   0.6.33    2023-07-07 [1] CRAN (R 4.3.0)\n doParallel               1.0.17    2022-02-07 [1] CRAN (R 4.3.0)\n dotCall64                1.1-1     2023-11-28 [1] CRAN (R 4.3.0)\n dplyr                    1.1.4     2023-11-17 [1] CRAN (R 4.3.0)\n dqrng                    0.3.2     2023-11-29 [1] CRAN (R 4.3.0)\n DT                       0.31      2023-12-09 [1] CRAN (R 4.3.0)\n edgeR                    4.0.3     2023-12-10 [1] Bioconductor\n ellipsis                 0.3.2     2021-04-29 [1] CRAN (R 4.3.0)\n evaluate                 0.23      2023-11-01 [1] CRAN (R 4.3.0)\n ExperimentHub          * 2.10.0    2023-10-24 [1] Bioconductor\n fansi                    1.0.6     2023-12-08 [1] CRAN (R 4.3.0)\n farver                   2.1.1     2022-07-06 [1] CRAN (R 4.3.0)\n fastmap                  1.1.1     2023-02-24 [1] CRAN (R 4.3.0)\n fields                   15.2      2023-08-17 [1] CRAN (R 4.3.0)\n filelock                 1.0.3     2023-12-11 [1] CRAN (R 4.3.0)\n FNN                      1.1.3.2   2023-03-20 [1] CRAN (R 4.3.0)\n foreach                  1.5.2     2022-02-02 [1] CRAN (R 4.3.0)\n generics                 0.1.3     2022-07-05 [1] CRAN (R 4.3.0)\n GenomeInfoDb           * 1.38.7    2024-03-06 [1] Bioconductor 3.18 (R 4.3.3)\n GenomeInfoDbData         1.2.11    2023-12-26 [1] Bioconductor\n GenomicAlignments        1.38.2    2024-01-16 [1] Bioconductor 3.18 (R 4.3.2)\n GenomicRanges          * 1.54.1    2023-10-29 [1] Bioconductor\n ggbeeswarm               0.7.2     2023-04-29 [1] CRAN (R 4.3.0)\n ggplot2                * 3.5.0     2024-02-23 [1] CRAN (R 4.3.2)\n ggrepel                  0.9.5     2024-01-10 [1] CRAN (R 4.3.0)\n glue                     1.7.0     2024-01-09 [1] CRAN (R 4.3.0)\n golem                    0.4.1     2023-06-05 [1] CRAN (R 4.3.0)\n gridExtra                2.3       2017-09-09 [1] CRAN (R 4.3.0)\n gtable                   0.3.4     2023-08-21 [1] CRAN (R 4.3.0)\n htmltools                0.5.7     2023-11-03 [1] CRAN (R 4.3.0)\n htmlwidgets              1.6.4     2023-12-06 [1] CRAN (R 4.3.0)\n httpuv                   1.6.13    2023-12-06 [1] CRAN (R 4.3.0)\n httr                     1.4.7     2023-08-15 [1] CRAN (R 4.3.0)\n igraph                 * 1.6.0     2023-12-11 [1] CRAN (R 4.3.0)\n interactiveDisplayBase   1.40.0    2023-10-24 [1] Bioconductor\n IRanges                * 2.36.0    2023-10-24 [1] Bioconductor\n irlba                    2.3.5.1   2022-10-03 [1] CRAN (R 4.3.0)\n iterators                1.0.14    2022-02-05 [1] CRAN (R 4.3.0)\n jquerylib                0.1.4     2021-04-26 [1] CRAN (R 4.3.0)\n jsonlite                 1.8.8     2023-12-04 [1] CRAN (R 4.3.0)\n KEGGREST                 1.42.0    2023-10-24 [1] Bioconductor\n knitr                    1.45      2023-10-30 [1] CRAN (R 4.3.0)\n labeling                 0.4.3     2023-08-29 [1] CRAN (R 4.3.0)\n later                    1.3.2     2023-12-06 [1] CRAN (R 4.3.0)\n lattice                  0.22-5    2023-10-24 [1] CRAN (R 4.3.3)\n lazyeval                 0.2.2     2019-03-15 [1] CRAN (R 4.3.0)\n lifecycle                1.0.4     2023-11-07 [1] CRAN (R 4.3.0)\n limma                    3.58.1    2023-10-31 [1] Bioconductor\n lobstr                 * 1.1.2     2022-06-22 [1] CRAN (R 4.3.0)\n locfit                   1.5-9.8   2023-06-11 [1] CRAN (R 4.3.0)\n magick                   2.8.3     2024-02-18 [1] CRAN (R 4.3.2)\n magrittr                 2.0.3     2022-03-30 [1] CRAN (R 4.3.0)\n maps                     3.4.2     2023-12-15 [1] CRAN (R 4.3.0)\n Matrix                   1.6-5     2024-01-11 [1] CRAN (R 4.3.3)\n MatrixGenerics         * 1.14.0    2023-10-24 [1] Bioconductor\n matrixStats            * 1.2.0     2023-12-11 [1] CRAN (R 4.3.0)\n memoise                  2.0.1     2021-11-26 [1] CRAN (R 4.3.0)\n metapod                  1.10.1    2023-12-24 [1] Bioconductor 3.18 (R 4.3.2)\n mime                     0.12      2021-09-28 [1] CRAN (R 4.3.0)\n munsell                  0.5.0     2018-06-12 [1] CRAN (R 4.3.0)\n paletteer                1.6.0     2024-01-21 [1] CRAN (R 4.3.0)\n pillar                   1.9.0     2023-03-22 [1] CRAN (R 4.3.0)\n pkgconfig                2.0.3     2019-09-22 [1] CRAN (R 4.3.0)\n plotly                   4.10.4    2024-01-13 [1] CRAN (R 4.3.0)\n png                      0.1-8     2022-11-29 [1] CRAN (R 4.3.0)\n prettyunits              1.2.0     2023-09-24 [1] CRAN (R 4.3.0)\n promises                 1.2.1     2023-08-10 [1] CRAN (R 4.3.0)\n purrr                    1.0.2     2023-08-10 [1] CRAN (R 4.3.0)\n R6                       2.5.1     2021-08-19 [1] CRAN (R 4.3.0)\n rappdirs                 0.3.3     2021-01-31 [1] CRAN (R 4.3.0)\n RColorBrewer             1.1-3     2022-04-03 [1] CRAN (R 4.3.0)\n Rcpp                     1.0.12    2024-01-09 [1] CRAN (R 4.3.0)\n RCurl                    1.98-1.14 2024-01-09 [1] CRAN (R 4.3.0)\n rematch2                 2.1.2     2020-05-01 [1] CRAN (R 4.3.0)\n restfulr                 0.0.15    2022-06-16 [1] CRAN (R 4.3.0)\n rjson                    0.2.21    2022-01-09 [1] CRAN (R 4.3.0)\n rlang                    1.1.3     2024-01-10 [1] CRAN (R 4.3.0)\n rmarkdown                2.25      2023-09-18 [1] CRAN (R 4.3.0)\n Rsamtools                2.18.0    2023-10-24 [1] Bioconductor\n RSQLite                  2.3.5     2024-01-21 [1] CRAN (R 4.3.0)\n rsvd                     1.0.5     2021-04-16 [1] CRAN (R 4.3.0)\n rtracklayer            * 1.62.0    2023-10-24 [1] Bioconductor\n S4Arrays                 1.2.1     2024-03-06 [1] Bioconductor 3.18 (R 4.3.3)\n S4Vectors              * 0.40.2    2023-11-23 [1] Bioconductor\n sass                     0.4.8     2023-12-06 [1] CRAN (R 4.3.0)\n ScaledMatrix             1.10.0    2023-10-24 [1] Bioconductor\n scales                   1.3.0     2023-11-28 [1] CRAN (R 4.3.0)\n scater                 * 1.30.1    2023-12-06 [1] Bioconductor\n scran                  * 1.30.0    2023-10-24 [1] Bioconductor\n scuttle                * 1.12.0    2023-10-24 [1] Bioconductor\n sessioninfo              1.2.2     2021-12-06 [1] CRAN (R 4.3.0)\n shiny                    1.8.0     2023-11-17 [1] CRAN (R 4.3.0)\n shinyWidgets             0.8.2     2024-03-01 [1] CRAN (R 4.3.2)\n SingleCellExperiment   * 1.24.0    2023-10-24 [1] Bioconductor\n spam                     2.10-0    2023-10-23 [1] CRAN (R 4.3.0)\n SparseArray              1.2.4     2024-02-11 [1] Bioconductor 3.18 (R 4.3.2)\n sparseMatrixStats        1.14.0    2023-10-24 [1] Bioconductor\n SpatialExperiment      * 1.13.1    2024-03-15 [1] Bioconductor\n spatialLIBD            * 1.14.1    2023-11-30 [1] Bioconductor 3.18 (R 4.3.3)\n statmod                  1.5.0     2023-01-06 [1] CRAN (R 4.3.0)\n STexampleData          * 1.10.0    2023-10-26 [1] Bioconductor\n SummarizedExperiment   * 1.32.0    2023-10-24 [1] Bioconductor\n tibble                   3.2.1     2023-03-20 [1] CRAN (R 4.3.0)\n tidyr                    1.3.1     2024-01-24 [1] CRAN (R 4.3.2)\n tidyselect               1.2.1     2024-03-11 [1] CRAN (R 4.3.2)\n utf8                     1.2.4     2023-10-22 [1] CRAN (R 4.3.0)\n uwot                     0.1.16    2023-06-29 [1] CRAN (R 4.3.0)\n vctrs                    0.6.5     2023-12-01 [1] CRAN (R 4.3.0)\n vipor                    0.4.7     2023-12-18 [1] CRAN (R 4.3.0)\n viridis                  0.6.4     2023-07-22 [1] CRAN (R 4.3.0)\n viridisLite              0.4.2     2023-05-02 [1] CRAN (R 4.3.0)\n withr                    3.0.0     2024-01-16 [1] CRAN (R 4.3.0)\n xfun                     0.42      2024-02-08 [1] CRAN (R 4.3.2)\n XML                      3.99-0.16 2023-11-29 [1] CRAN (R 4.3.0)\n xtable                   1.8-4     2019-04-21 [1] CRAN (R 4.3.0)\n XVector                  0.42.0    2023-10-24 [1] Bioconductor\n yaml                     2.3.8     2023-12-11 [1] CRAN (R 4.3.0)\n zlibbioc                 1.48.2    2024-03-13 [1] Bioconductor 3.18 (R 4.3.3)\n\n [1] /Library/Frameworks/R.framework/Versions/4.3-x86_64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n\n\n\n\n\n\nMaynard, Kristen R., Leonardo Collado-Torres, Lukas M. Weber, Cedric Uytingco, Brianna K. Barry, Stephen R. Williams, Joseph L. Catallini II, et al. 2021. “Transcriptome-Scale Spatial Gene Expression in the Human Dorsolateral Prefrontal Cortex.” Nature Neuroscience 24: 425–36. https://doi.org/10.1038/s41593-020-00787-0.\n\n\nPardo, Brenda, Abby Spangler, Lukas M. Weber, Stephanie C. Page, Stephanie C. Hicks, Andrew E. Jaffe, Keri Martinowich, Kristen R. Maynard, and Leonardo Collado-Torres. 2022. “spatialLIBD: An R/Bioconductor Package to Visualize Spatially-Resolved Transcriptomics Data.” BMC Genomics, no. 23: 434. https://doi.org/10.1186/s12864-022-08601-w."
  },
  {
    "objectID": "chapters/workflow-Visium-spatialLIBD.html#footnotes",
    "href": "chapters/workflow-Visium-spatialLIBD.html#footnotes",
    "title": "19  spatialLIBD workflow",
    "section": "",
    "text": "Check https://github.com/LieberInstitute/spatialLIBD#shiny-website-mirrors in case you need to use a mirror. shiny-powered websites work best on browsers such as Google Chrome and Mozilla Firefox, among others.↩︎\nOriginally available at https://github.com/LieberInstitute/spatialLIBD/blob/master/inst/app/www/documentation_spe.md#slides-and-videos.↩︎\nThis book is under development, so right now you actually need to use bioc-devel. Once this book is submitted to Bioconductor, then it’ll work with bioc-release. TODO: remove this comment when the book is available on bioc-release.↩︎"
  },
  {
    "objectID": "chapters/related-resources.html#overview",
    "href": "chapters/related-resources.html#overview",
    "title": "Appendix A — Related resources",
    "section": "A.1 Overview",
    "text": "A.1 Overview\nIn this chapter, we highlight several related resources from the Bioconductor and other communities."
  },
  {
    "objectID": "chapters/related-resources.html#data-preprocessing-procedures-for-the-visium-platform",
    "href": "chapters/related-resources.html#data-preprocessing-procedures-for-the-visium-platform",
    "title": "Appendix A — Related resources",
    "section": "A.2 Data preprocessing procedures for the Visium platform",
    "text": "A.2 Data preprocessing procedures for the Visium platform\nData preprocessing procedures for spatial transcriptomics data from the 10x Genomics Visium platform:\n\nVisium data preprocessing: Online book containing details on data preprocessing procedures for spatial transcriptomics data from the 10x Genomics Visium platform (using tools outside R and Bioconductor)."
  },
  {
    "objectID": "chapters/related-resources.html#resources-for-other-spatial-omics-platforms",
    "href": "chapters/related-resources.html#resources-for-other-spatial-omics-platforms",
    "title": "Appendix A — Related resources",
    "section": "A.3 Resources for other spatial omics platforms",
    "text": "A.3 Resources for other spatial omics platforms\nWorkflows and other resources for other spatial omics platforms:\n\nAnalysis workflow for IMC data: Online book providing a workflow highlighting the use of common R/Bioconductor packages to analyze single-cell data obtained from segmented imaging mass cytometry (IMC) images. Examples focus on IMC data and can also be applied to images obtained by other highly-multiplexed imaging technologies, e.g. CODEX, MIBI, and mIF.\nVectraPolarisData: Bioconductor data package providing two multiplex single-cell imaging datasets collected on Vectra Polaris and Vectra 3 instruments."
  },
  {
    "objectID": "chapters/related-resources.html#data-structures",
    "href": "chapters/related-resources.html#data-structures",
    "title": "Appendix A — Related resources",
    "section": "A.4 Data structures",
    "text": "A.4 Data structures\nData structures for storing spatial transcriptomics and other spatial omics data that have not already been discussed in Chapter 3:\n\nAnnData: Python class for storing single-cell and spatial data within the scverse framework.\nSpatialData: Python class for storing data from spatial transcriptomics and other spatial omics platforms."
  },
  {
    "objectID": "chapters/related-resources.html#statistical-concepts",
    "href": "chapters/related-resources.html#statistical-concepts",
    "title": "Appendix A — Related resources",
    "section": "A.5 Statistical concepts",
    "text": "A.5 Statistical concepts\n\nModern Statistics for Modern Biology: Online textbook on concepts in modern statistics for high-throughput and high-dimensional biology, including chapter on image data and spatial statistics."
  },
  {
    "objectID": "chapters/acknowledgments.html#contributors",
    "href": "chapters/acknowledgments.html#contributors",
    "title": "Appendix B — Acknowledgments",
    "section": "B.1 Contributors",
    "text": "B.1 Contributors\nMain developers of the ‘Best Practices for Spatial Transcriptomics Analysis with Bioconductor’ online book:\n\nLukas M. Weber, Johns Hopkins Bloomberg School of Public Health, Baltimore, MD, USA\nLeonardo Collado-Torres, Lieber Institute for Brain Development, Baltimore, MD, USA\nStephanie C. Hicks, Johns Hopkins Bloomberg School of Public Health, Baltimore, MD, USA\n\nWe are also grateful to additional GitHub contributors who have contributed materials, including updates, extensions, bug fixes, and other improvements. Thank you for your contributions!"
  },
  {
    "objectID": "chapters/acknowledgments.html#additional-acknowledgments",
    "href": "chapters/acknowledgments.html#additional-acknowledgments",
    "title": "Appendix B — Acknowledgments",
    "section": "B.2 Additional acknowledgments",
    "text": "B.2 Additional acknowledgments\n\nThe ‘Best Practices for Spatial Transcriptomics Analysis with Bioconductor’ online book is inspired by the Orchestrating Single-Cell Analysis with Bioconductor (OSCA) online book (Amezquita et al. 2020), which provides a detailed overview and examples of analysis workflows for single-cell RNA sequencing data using R and Bioconductor.\nWe are especially grateful to the Bioconductor community and the Bioconductor Core Team.\n\n\n\n\n\nAmezquita, Robert A., Aaron T. L. Lun, Etienne Becht, Vince J. Carey, Lindsay N. Carpp, Ludwig Geistlinger, Federico Marini, et al. 2020. “Orchestrating Single-Cell Analysis with Bioconductor.” Nature Methods 17: 137–45. https://doi.org/10.1038/s41592-019-0654-x."
  },
  {
    "objectID": "chapters/references.html",
    "href": "chapters/references.html",
    "title": "References",
    "section": "",
    "text": "Amezquita, Robert A., Aaron T. L. Lun, Etienne Becht, Vince J. Carey,\nLindsay N. Carpp, Ludwig Geistlinger, Federico Marini, et al. 2020.\n“Orchestrating Single-Cell Analysis with\nBioconductor.” Nature Methods 17: 137–45.\nhttps://doi.org/10.1038/s41592-019-0654-x.\n\n\nBressan, Dario, Giorgia Battistoni, and Gregory J. Hannon. 2023.\n“The Dawn of Spatial Omics.” Science 381 (6657).\nhttps://doi.org/10.1126/science.abq4964.\n\n\nCanete, Nicolas P., Sourish S. Iyengar, John T. Ormerod, Heeva Baharlou,\nAndrew N. Harman, and Ellis Patrick. 2022. “spicyR: Spatial Analysis of in Situ Cytometry Data\nin R.” Bioinformatics 38: 3099–3105. https://doi.org/10.1093/bioinformatics/btac268.\n\n\nHu, Jian, Xiangjie Li, Kyle Coleman, Amelia Schroeder, Nan Ma, David J.\nIrwin, Edward B. Lee, Russell T. Shinohara, and Mingyao Li. 2021.\n“SpaGCN: Integrating Gene Expression,\nSpatial Location and Histology to Identify Spatial Domains and Spatially\nVariable Genes by Graph Convolutional Network.” Nature\nMethods 18: 1342–51. https://doi.org/10.1038/s41592-021-01255-8.\n\n\nHuber, Wolfgang, Vincent J. Carey, Robert Gentleman, Simon Anders, Marc\nCarlson, Benilton S. Carvalho, Hector Corrada Bravo, et al. 2015.\n“Orchestrating High-Throughput Genomic Analysis with\nBioconductor.” Nature Methods 12: 115–21.\nhttps://doi.org/10.1038/nmeth.3252.\n\n\nLiu, Wei, Xu Liao, Ziye Luo, Yi Yang, Mai Chan Lau, Yuling Jiao, Xingjie\nShi, et al. 2023. “Probabilistic Embedding, Clustering, and\nAlignment for Integrating Spatial Transcriptomics Data with\nPRECAST.” Nature Communications 14: 296. https://doi.org/10.1038/s41467-023-35947-w.\n\n\nLun, Aaron T. L., Davis J. McCarthy, and John C. Marioni. 2016. “A\nStep-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with\nBioconductor.” F1000Research 5 (2122). https://doi.org/10.12688/f1000research.9501.2.\n\n\nMaynard, Kristen R., Leonardo Collado-Torres, Lukas M. Weber, Cedric\nUytingco, Brianna K. Barry, Stephen R. Williams, Joseph L. Catallini II,\net al. 2021. “Transcriptome-Scale Spatial Gene Expression in the\nHuman Dorsolateral Prefrontal Cortex.” Nature\nNeuroscience 24: 425–36. https://doi.org/10.1038/s41593-020-00787-0.\n\n\nMcCarthy, Davis J., Kieran R. Campbell, Aaron T. L. Lun, and Quin F.\nWills. 2017. “Scater: Pre-Processing, Quality\nControl, Normalization and Visualization of Single-Cell RNA-seq Data in R.”\nBioinformatics 33 (8): 1179–86. https://doi.org/10.1093/bioinformatics/btw777.\n\n\nMoses, Lambda, Pétur Helgi Einarsson, Kayla Jackson, Laura Luebbert, A.\nSina Booeshaghi, Sindri Antonsson, Nicolas Bray, Páll Melsted, and Lior\nPachter. 2023. “Voyager: Exploratory Single-Cell\nGenomics Data Analysis with Geospatial Statistics.”\nbioRxiv. https://doi.org/10.1101/2023.07.20.549945.\n\n\nMoses, Lambda, and Lior Pachter. 2022. “Museum of Spatial\nTranscriptomics.” Nature Methods 19: 534–46. https://doi.org/10.1038/s41592-022-01409-2.\n\n\nPardo, Brenda, Abby Spangler, Lukas M. Weber, Stephanie C. Page,\nStephanie C. Hicks, Andrew E. Jaffe, Keri Martinowich, Kristen R.\nMaynard, and Leonardo Collado-Torres. 2022. “spatialLIBD: An R/Bioconductor\nPackage to Visualize Spatially-Resolved Transcriptomics Data.”\nBMC Genomics, no. 23: 434. https://doi.org/10.1186/s12864-022-08601-w.\n\n\nPeters Couto, Bárbara Zita, Nicholas Robertson, Ellis Patrick, and Shila\nGhazanfar. 2023. “MoleculeExperiment Enables\nConsistent Infrastructure for Molecule-Resolved Spatial Transcriptomics\nData in Bioconductor.” bioRxiv. https://doi.org/10.1101/2023.05.16.541040.\n\n\nRighelli, Dario, Lukas M. Weber, Helena L. Crowell, Brenda Pardo,\nLeonardo Collado-Torres, Shila Ghazanfar, Aaron T. L. Lun, Stephanie C.\nHicks, and Davide Risso. 2022. “SpatialExperiment:\nInfrastructure for Spatially-Resolved Transcriptomics Data in\nR Using Bioconductor.”\nBioinformatics 38 (11): 3128–31. https://doi.org/10.1093/bioinformatics/btac299.\n\n\nSinghal, Vipul, Nigel Chou, Joseph Lee, Yifei Yue, Jinyue Liu, Wan Kee\nChock, Li Lin, et al. 2024. “BANKSY Unifies Cell\nTyping and Tissue Domain Segmentation for Scalable Spatial Omics Data\nAnalysis.” Nature Genetics. https://doi.org/10.1038/s41588-024-01664-3.\n\n\nStåhl, Patrik L., Fredrik Salmén, Sanja Vickovic, Anna Lundmark, José\nFernández Navarro, Jens Magnusson, Stefania Giacomello, et al. 2016.\n“Visualization and Analysis of Gene Expression in Tissue Sections\nby Spatial Transcriptomics.” Science 353 (6294): 78–82.\nhttps://doi.org/10.1126/science.aaf2403.\n\n\nStickels, Robert R., Evan Murray, Pawan Kumar, Jilong Li, Jamie L.\nMarshall, Daniela J. Di Bella, Paola Arlotta, Evan Z. Macosko, and Fei\nChen. 2021. “Highly Sensitive Spatial Transcriptomics at\nNear-Cellular Resolution with Slide-seqV2.” Nature Biotechnology\n39: 313–19. https://doi.org/10.1038/s41587-020-0739-1.\n\n\nSun, Shiquan, Jiaqiang Zhu, and Xiang Zhou. 2020. “Statistical\nAnalysis of Spatial Expression Patterns for Spatially Resolved\nTranscriptomic Studies.” Nature Methods 17: 193–200. https://doi.org/10.1038/s41592-019-0701-7.\n\n\nSvensson, Valentine, Sarah A. Teichmann, and Oliver Stegle. 2018.\n“SpatialDE: Identification of Spatially Variable\nGenes.” Nature Methods 15: 343–46. https://doi.org/10.1038/nmeth.4636.\n\n\nWeber, Lukas M., Arkajyoti Saha, Abhirup Datta, Kasper D. Hansen, and\nStephanie C. Hicks. 2023. “nnSVG for\nthe Scalable Identification of Spatially Variable Genes Using\nNearest-Neighbor Gaussian Processes.” Nature\nCommunications 14: 4059. https://doi.org/10.1038/s41467-023-39748-z.\n\n\nZhao, Edward, Matthew R. Stone, Xing Ren, Jamie Guenthoer, Kimberly S.\nSmythe, Thomas Pulliam, Stephen R. Williams, et al. 2021. “Spatial\nTranscriptomics at Subspot Resolution with\nBayesSpace.” Nature Biotechnology 39:\n1375–84. https://doi.org/10.1038/s41587-021-00935-2.\n\n\nZhu, Jiaqiang, Shiquan Sun, and Xiang Zhou. 2021.\n“SPARK-X: Non-Parametric Modeling Enables Scalable\nand Robust Detection of Spatial Expression Patterns for Large Spatial\nTranscriptomic Studies.” Genome Biology 22: 184. https://doi.org/10.1186/s13059-021-02404-0."
  }
]